Index: include/llvm/CodeGen/Passes.h
===================================================================
--- include/llvm/CodeGen/Passes.h	(revision 283887)
+++ include/llvm/CodeGen/Passes.h	(working copy)
@@ -393,6 +393,9 @@
 
   /// This pass frees the memory occupied by the MachineFunction.
   FunctionPass *createFreeMachineFunctionPass();
+
+  FunctionPass *createMachineGroundTruth_FunctionPass();
+
 } // End llvm namespace
 
 /// Target machine pass initializer for passes with dependencies. Use with
Index: include/llvm/Transforms/IPO.h
===================================================================
--- include/llvm/Transforms/IPO.h	(revision 283887)
+++ include/llvm/Transforms/IPO.h	(working copy)
@@ -227,6 +227,8 @@
 ModulePass *createSampleProfileLoaderPass();
 ModulePass *createSampleProfileLoaderPass(StringRef Name);
 
+Pass *createGroundTruth_FunctionPass();
+
 } // End llvm namespace
 
 #endif
Index: lib/CodeGen/AsmPrinter/AsmPrinter.cpp
===================================================================
--- lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(revision 283887)
+++ lib/CodeGen/AsmPrinter/AsmPrinter.cpp	(working copy)
@@ -826,6 +826,57 @@
                              MCConstantExpr::create(FrameOffset, OutContext));
 }
 
+namespace {
+
+static bool isIndirCS(ImmutableCallSite &CS)
+{
+  if (!CS.isCall())
+    return false;
+
+  if (CS.getCalledFunction() || !CS.getCalledValue())
+    return false;
+
+  Instruction const *I = CS.getInstruction();
+  if (CallInst const *CI = dyn_cast<CallInst>(I)) {
+    if (CI->isInlineAsm())
+      return false;
+  }
+  if (isa<Constant>(CS.getCalledValue()))
+    return false;
+
+  return true;
+}
+
+static void indirCallSiteCheck(MachineInstr const& MI, MachineBasicBlock const& MBB, MachineFunction const& MF) {
+  auto F = MF.getFunction();
+
+  if (auto bb = MBB.getBasicBlock()) {
+    for (auto const& instr : *bb) {
+      ImmutableCallSite cs(&instr);
+
+      if (isIndirCS(cs)) {
+        if (!cs.isMustTailCall()) {
+          errs().write_escaped(F->getName()) << "; ";
+          errs() << ("<CGCS>") << "; ";
+
+          auto site_arguments = 0;
+
+          for (auto const &arg : cs.args()) {
+            errs() << (*arg->getType()) << "; ";
+            site_arguments++;
+          }
+          for (auto i = site_arguments; i < 6; ++i)
+            errs() << "; ";
+
+          errs() << "parameter_count " << site_arguments << ";";
+          errs() << "return_type " << (*cs.getType()) << ";" << '\n';
+        }
+      }
+    }
+  }
+}
+}
+
 /// EmitFunctionBody - This method emits the body and trailer for a
 /// function.
 void AsmPrinter::EmitFunctionBody() {
@@ -889,7 +940,9 @@
       case TargetOpcode::KILL:
         if (isVerbose()) emitKill(&MI, *this);
         break;
-      default:
+      default: 
+        //if (MI.isCall())
+          //indirCallSiteCheck(MI, MBB, *MF);
         EmitInstruction(&MI);
         break;
       }
Index: lib/CodeGen/CMakeLists.txt
===================================================================
--- lib/CodeGen/CMakeLists.txt	(revision 283887)
+++ lib/CodeGen/CMakeLists.txt	(working copy)
@@ -64,6 +64,7 @@
   MachineFunction.cpp
   MachineFunctionPass.cpp
   MachineFunctionPrinterPass.cpp
+  MachineGroundTruth.cpp
   MachineInstrBundle.cpp
   MachineInstr.cpp
   MachineLICM.cpp
Index: lib/CodeGen/ParallelCG.cpp
===================================================================
--- lib/CodeGen/ParallelCG.cpp	(revision 283887)
+++ lib/CodeGen/ParallelCG.cpp	(working copy)
@@ -12,6 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/CodeGen/ParallelCG.h"
+#include "llvm/CodeGen/Passes.h"
 #include "llvm/Bitcode/ReaderWriter.h"
 #include "llvm/IR/LLVMContext.h"
 #include "llvm/IR/LegacyPassManager.h"
Index: lib/CodeGen/TargetPassConfig.cpp
===================================================================
--- lib/CodeGen/TargetPassConfig.cpp	(revision 283887)
+++ lib/CodeGen/TargetPassConfig.cpp	(working copy)
@@ -671,6 +671,8 @@
   addPass(&XRayInstrumentationID, false);
   addPass(&PatchableFunctionID, false);
 
+  addPass(createMachineGroundTruth_FunctionPass());
+
   AddingMachinePasses = false;
 }
 
Index: lib/Target/X86/CMakeLists.txt
===================================================================
--- lib/Target/X86/CMakeLists.txt	(revision 283887)
+++ lib/Target/X86/CMakeLists.txt	(working copy)
@@ -28,6 +28,7 @@
   X86InstrInfo.cpp
   X86MCInstLower.cpp
   X86MachineFunctionInfo.cpp
+  X86MachineGroundTruth.cpp
   X86OptimizeLEAs.cpp
   X86PadShortFunction.cpp
   X86RegisterInfo.cpp
Index: lib/Target/X86/X86.h
===================================================================
--- lib/Target/X86/X86.h	(revision 283887)
+++ lib/Target/X86/X86.h	(working copy)
@@ -86,6 +86,8 @@
 /// the upper portions of registers, and to save code size.
 FunctionPass *createX86FixupBWInsts();
 
+FunctionPass *createX86MachineGroundTruth_FunctionPass();
+
 void initializeFixupBWInstPassPass(PassRegistry &);
 } // End llvm namespace
 
Index: lib/Target/X86/X86MCInstLower.cpp
===================================================================
--- lib/Target/X86/X86MCInstLower.cpp	(revision 283887)
+++ lib/Target/X86/X86MCInstLower.cpp	(working copy)
@@ -45,6 +45,7 @@
 #include "llvm/Support/ELF.h"
 #include "llvm/Target/TargetLoweringObjectFile.h"
 
+
 using namespace llvm;
 
 namespace {
@@ -1256,6 +1257,84 @@
   return Comment;
 }
 
+namespace {
+
+static bool callsiteOpcodeCheck(MachineInstr const& MI)
+{
+  switch(MI.getOpcode())
+  {
+    case X86::CALLpcrel32: errs() << "X86::CALLpcrel32:\n"; break;
+    case X86::CALLpcrel16: errs() << "X86::CALLpcrel16:\n"; break;
+    case X86::CALL16r: errs() << "X86::CALL16r:\n"; break;
+    case X86::CALL16m: errs() << "X86::CALL16m:\n"; break;
+    case X86::CALL32r: errs() << "X86::CALL32r:\n"; break;
+    case X86::CALL32m: errs() << "X86::CALL32m:\n"; break;
+    case X86::FARCALL16i: errs() << "X86::FARCALL16i:\n"; break;
+    case X86::FARCALL32i: errs() << "X86::FARCALL32i:\n"; break;
+    case X86::FARCALL16m: errs() << "X86::FARCALL16m:\n"; break;
+    case X86::FARCALL32m: errs() << "X86::FARCALL32m:\n"; break;
+    case X86::CALL64pcrel32: errs() << "X86::CALL64pcrel32:\n"; break;
+    case X86::CALL64r: errs() << "X86::CALL64r:\n"; break;
+    case X86::CALL64m: errs() << "X86::CALL64m:\n"; break;
+    case X86::FARCALL64: errs() << "X86::FARCALL64:\n"; break; 
+   default:
+      return false;
+  }
+  return true;
+}
+
+static bool isIndirCS(ImmutableCallSite &CS)
+{ 
+  if (!CS.isCall())
+    return false;
+  
+  if (CS.getCalledFunction() || !CS.getCalledValue())
+    return false;
+  
+  Instruction const *I = CS.getInstruction();
+  if (CallInst const *CI = dyn_cast<CallInst>(I)) {
+    if (CI->isInlineAsm())
+      return false;
+  }
+  if (isa<Constant>(CS.getCalledValue()))
+    return false;
+  
+  return true;
+}
+
+static void indirCallSiteCheck(MachineInstr const& MI, MachineBasicBlock const& MBB, MachineFunction const& MF) {
+  if (!callsiteOpcodeCheck(MI))
+    return;
+
+  auto F = MF.getFunction();
+
+  if (auto bb = MBB.getBasicBlock()) {
+    for (auto const& instr : *bb) {
+      ImmutableCallSite cs(&instr);
+
+      if (isIndirCS(cs)) {
+        if (!cs.isMustTailCall()) {
+          errs().write_escaped(F->getName()) << "; ";
+          errs() << ("<CGCS>") << "; ";
+
+          auto site_arguments = 0;
+
+          for (auto const &arg : cs.args()) {
+            errs() << (*arg->getType()) << "; ";
+            site_arguments++;
+          }
+          for (auto i = site_arguments; i < 6; ++i)
+            errs() << "; ";
+
+          errs() << "parameter_count " << site_arguments << ";";
+          errs() << "return_type " << (*cs.getType()) << ";" << '\n';
+        }
+      }
+    }
+  }
+}
+}
+
 void X86AsmPrinter::EmitInstruction(const MachineInstr *MI) {
   X86MCInstLower MCInstLowering(*MF, *this);
   const X86RegisterInfo *RI = MF->getSubtarget<X86Subtarget>().getRegisterInfo();
@@ -1723,6 +1802,7 @@
   // in to the stackmap shadow.  The only way to achieve this is if the call
   // is at the end of the shadow.
   if (MI->isCall()) {
+    //indirCallSiteCheck(*MI, *(MI->getParent()), *MF);
     // Count then size of the call towards the shadow
     SMShadowTracker.count(TmpInst, getSubtargetInfo(), CodeEmitter.get());
     // Then flush the shadow so that we fill with nops before the call, not
Index: lib/Target/X86/X86TargetMachine.cpp
===================================================================
--- lib/Target/X86/X86TargetMachine.cpp	(revision 283887)
+++ lib/Target/X86/X86TargetMachine.cpp	(working copy)
@@ -327,4 +327,6 @@
     addPass(createX86PadShortFunctions());
     addPass(createX86FixupLEAs());
   }
+
+  addPass(createX86MachineGroundTruth_FunctionPass());
 }
Index: lib/Transforms/IPO/CMakeLists.txt
===================================================================
--- lib/Transforms/IPO/CMakeLists.txt	(revision 283887)
+++ lib/Transforms/IPO/CMakeLists.txt	(working copy)
@@ -12,6 +12,7 @@
   FunctionImport.cpp
   GlobalDCE.cpp
   GlobalOpt.cpp
+  GroundTruth.cpp
   IPConstantPropagation.cpp
   IPO.cpp
   InferFunctionAttrs.cpp
Index: lib/Transforms/IPO/PassManagerBuilder.cpp
===================================================================
--- lib/Transforms/IPO/PassManagerBuilder.cpp	(revision 283887)
+++ lib/Transforms/IPO/PassManagerBuilder.cpp	(working copy)
@@ -403,6 +403,7 @@
       MPM.add(createNameAnonGlobalPass());
 
     addExtensionsToPM(EP_EnabledOnOptLevel0, MPM);
+    MPM.add(createGroundTruth_FunctionPass());
     return;
   }
 
@@ -644,6 +645,7 @@
     MPM.add(createMergeFunctionsPass());
 
   addExtensionsToPM(EP_OptimizerLast, MPM);
+  MPM.add(createGroundTruth_FunctionPass());
 }
 
 void PassManagerBuilder::addLTOOptimizationPasses(legacy::PassManagerBase &PM) {
@@ -818,6 +820,8 @@
 
   if (VerifyOutput)
     PM.add(createVerifierPass());
+
+//  PM.add(createGroundTruth_FunctionPass());
   PerformThinLTO = false;
 }
 
@@ -845,6 +849,8 @@
 
   if (VerifyOutput)
     PM.add(createVerifierPass());
+
+//  PM.add(createGroundTruth_FunctionPass());
 }
 
 inline PassManagerBuilder *unwrap(LLVMPassManagerBuilderRef P) {
Index: tools/gold/gold-plugin.cpp
===================================================================
--- tools/gold/gold-plugin.cpp	(revision 283887)
+++ tools/gold/gold-plugin.cpp	(working copy)
@@ -842,6 +842,7 @@
   if (options::thinlto_index_only) {
     cleanup_hook();
     exit(0);
+    }
   }
 
   for (unsigned I = 0; I != MaxTasks; ++I)
