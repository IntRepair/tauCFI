Index: CodeGen/AsmPrinter/AsmPrinter.cpp
===================================================================
--- CodeGen/AsmPrinter/AsmPrinter.cpp	(revision 300780)
+++ CodeGen/AsmPrinter/AsmPrinter.cpp	(working copy)
@@ -952,6 +952,57 @@
                              MCConstantExpr::create(FrameOffset, OutContext));
 }
 
+namespace {
+
+static bool isIndirCS(ImmutableCallSite &CS)
+{
+  if (!CS.isCall())
+    return false;
+
+  if (CS.getCalledFunction() || !CS.getCalledValue())
+    return false;
+
+  Instruction const *I = CS.getInstruction();
+  if (CallInst const *CI = dyn_cast<CallInst>(I)) {
+    if (CI->isInlineAsm())
+      return false;
+  }
+  if (isa<Constant>(CS.getCalledValue()))
+    return false;
+
+  return true;
+}
+
+static void indirCallSiteCheck(MachineInstr const& MI, MachineBasicBlock const& MBB, MachineFunction const& MF) {
+  auto F = MF.getFunction();
+
+  if (auto bb = MBB.getBasicBlock()) {
+    for (auto const& instr : *bb) {
+      ImmutableCallSite cs(&instr);
+
+      if (isIndirCS(cs)) {
+        if (!cs.isMustTailCall()) {
+          errs().write_escaped(F->getName()) << "; ";
+          errs() << ("<CGCS>") << "; ";
+
+          auto site_arguments = 0;
+
+          for (auto const &arg : cs.args()) {
+            errs() << (*arg->getType()) << "; ";
+            site_arguments++;
+          }
+          for (auto i = site_arguments; i < 6; ++i)
+            errs() << "; ";
+
+          errs() << "parameter_count " << site_arguments << ";";
+          errs() << "return_type " << (*cs.getType()) << ";" << '\n';
+        }
+      }
+    }
+  }
+}
+}
+
 /// EmitFunctionBody - This method emits the body and trailer for a
 /// function.
 void AsmPrinter::EmitFunctionBody() {
@@ -1017,7 +1068,9 @@
       case TargetOpcode::KILL:
         if (isVerbose()) emitKill(&MI, *this);
         break;
-      default:
+      default: 
+        //if (MI.isCall())
+          //indirCallSiteCheck(MI, MBB, *MF);
         EmitInstruction(&MI);
         break;
       }
Index: CodeGen/CMakeLists.txt
===================================================================
--- CodeGen/CMakeLists.txt	(revision 300780)
+++ CodeGen/CMakeLists.txt	(working copy)
@@ -68,6 +68,8 @@
   MachineFunction.cpp
   MachineFunctionPass.cpp
   MachineFunctionPrinterPass.cpp
+  MachineGroundTruth.cpp
+  MachineCallSiteAugment.cpp
   MachineInstrBundle.cpp
   MachineInstr.cpp
   MachineLICM.cpp
Index: CodeGen/MIRParser/MIParser.cpp
===================================================================
--- CodeGen/MIRParser/MIParser.cpp	(revision 300780)
+++ CodeGen/MIRParser/MIParser.cpp	(working copy)
@@ -693,6 +693,7 @@
   }
 
   // TODO: Check for extraneous machine operands.
+  errs() << MF.getName() << " MachineFunction::CreateMachineInstr() MIParser\n";
   MI = MF.CreateMachineInstr(MCID, DebugLocation, /*NoImplicit=*/true);
   MI->setFlags(Flags);
   for (const auto &Operand : Operands)
Index: CodeGen/MachineFunction.cpp
===================================================================
--- CodeGen/MachineFunction.cpp	(revision 300780)
+++ CodeGen/MachineFunction.cpp	(working copy)
@@ -261,6 +261,8 @@
 MachineInstr *MachineFunction::CreateMachineInstr(const MCInstrDesc &MCID,
                                                   const DebugLoc &DL,
                                                   bool NoImp) {
+  if (getName() == "pg_qsort")
+    errs() << getName() << " MachineFunction::CreateMachineInstr()\n";
   return new (InstructionRecycler.Allocate<MachineInstr>(Allocator))
     MachineInstr(*this, MCID, DL, NoImp);
 }
Index: CodeGen/MachineInstr.cpp
===================================================================
--- CodeGen/MachineInstr.cpp	(revision 300780)
+++ CodeGen/MachineInstr.cpp	(working copy)
@@ -751,7 +751,7 @@
 MachineInstr::MachineInstr(MachineFunction &MF, const MachineInstr &MI)
     : MCID(&MI.getDesc()), Parent(nullptr), Operands(nullptr), NumOperands(0),
       Flags(0), AsmPrinterFlags(0), NumMemRefs(MI.NumMemRefs),
-      MemRefs(MI.MemRefs), debugLoc(MI.getDebugLoc()) {
+      MemRefs(MI.MemRefs), debugLoc(MI.getDebugLoc()), callSite(MI.getCallSite()) {
   assert(debugLoc.hasTrivialDestructor() && "Expected trivial destructor");
 
   CapOperands = OperandCapacity::get(MI.getNumOperands());
Index: CodeGen/ParallelCG.cpp
===================================================================
--- CodeGen/ParallelCG.cpp	(revision 300780)
+++ CodeGen/ParallelCG.cpp	(working copy)
@@ -12,6 +12,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/CodeGen/ParallelCG.h"
+#include "llvm/CodeGen/Passes.h"
 #include "llvm/Bitcode/BitcodeReader.h"
 #include "llvm/Bitcode/BitcodeWriter.h"
 #include "llvm/IR/LLVMContext.h"
Index: CodeGen/TargetInstrInfo.cpp
===================================================================
--- CodeGen/TargetInstrInfo.cpp	(revision 300780)
+++ CodeGen/TargetInstrInfo.cpp	(working copy)
@@ -464,6 +464,7 @@
       return nullptr;
   }
 
+  errs() << MF.getName() << " MachineFunction::CreateMachineInstr() TargetInstrInfo\n";
   MachineInstr *NewMI =
       MF.CreateMachineInstr(TII.get(MI.getOpcode()), MI.getDebugLoc(), true);
   MachineInstrBuilder MIB(MF, NewMI);
Index: CodeGen/TargetPassConfig.cpp
===================================================================
--- CodeGen/TargetPassConfig.cpp	(revision 300780)
+++ CodeGen/TargetPassConfig.cpp	(working copy)
@@ -592,11 +592,18 @@
   // Print the instruction selected machine code...
   printAndVerify("After Instruction Selection");
 
+  addPass(createMachineCallsiteAugment_FunctionPass());
+  addPass(createMachineCallsiteDumpIRFunctionPass("Stage 0"));
+  addPass(createMachineCallsiteDumpMRFunctionPass("Stage 0"));
+
   if (TM->Options.EnableIPRA)
     addPass(createRegUsageInfoPropPass());
 
   // Expand pseudo-instructions emitted by ISel.
   addPass(&ExpandISelPseudosID);
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage I"));
+  //addPass(createMachineCallsiteDumpIRFunctionPass("Stage I"));
+  //addPass(createMachineCallsiteDumpMRFunctionPass("Stage I"));
 
   // Add passes that optimize machine instructions in SSA form.
   if (getOptLevel() != CodeGenOpt::None) {
@@ -606,41 +613,57 @@
     // to one another and simplify frame index references where possible.
     addPass(&LocalStackSlotAllocationID, false);
   }
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage II"));
 
   // Run pre-ra passes.
   addPreRegAlloc();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage III"));
 
   // Run register allocation and passes that are tightly coupled with it,
   // including phi elimination and scheduling.
   if (getOptimizeRegAlloc())
+  {
     addOptimizedRegAlloc(createRegAllocPass(true));
+    addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVa"));
+  }
   else
+  {
     addFastRegAlloc(createRegAllocPass(false));
+    addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVb"));
+  }
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IV"));
 
   // Run post-ra passes.
   addPostRegAlloc();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage V"));
 
   // Insert prolog/epilog code.  Eliminate abstract frame index references...
   if (getOptLevel() != CodeGenOpt::None)
     addPass(&ShrinkWrapID);
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage VI"));
 
   // Prolog/Epilog inserter needs a TargetMachine to instantiate. But only
   // do so if it hasn't been disabled, substituted, or overridden.
   if (!isPassSubstitutedOrOverridden(&PrologEpilogCodeInserterID))
       addPass(createPrologEpilogInserterPass(TM));
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage VII"));
 
   /// Add passes that optimize machine instructions after register allocation.
   if (getOptLevel() != CodeGenOpt::None)
     addMachineLateOptimization();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage VIII"));
 
   // Expand pseudo instructions before second scheduling pass.
   addPass(&ExpandPostRAPseudosID);
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IX"));
 
   // Run pre-sched2 passes.
   addPreSched2();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage X"));
 
   if (EnableImplicitNullChecks)
     addPass(&ImplicitNullChecksID);
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XI"));;
 
   // Second pass scheduler.
   // Let Target optionally insert this pass by itself at some other
@@ -652,6 +675,7 @@
     else
       addPass(&PostRASchedulerID);
   }
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XII"));
 
   // GC
   if (addGCPasses()) {
@@ -658,12 +682,15 @@
     if (PrintGCInfo)
       addPass(createGCInfoPrinter(dbgs()), false, false);
   }
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XIII"));
 
   // Basic block placement.
   if (getOptLevel() != CodeGenOpt::None)
     addBlockPlacement();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XIV"));
 
   addPreEmitPass();
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XV"));
 
   if (TM->Options.EnableIPRA)
     // Collect register usage information and produce a register mask of
@@ -684,6 +711,12 @@
   if (EnableMachineOutliner)
     PM->add(createMachineOutlinerPass());
 
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage XVI"));
+  addPass(createMachineCallsiteDumpIRFunctionPass("Stage XVI"));
+  addPass(createMachineCallsiteDumpMRFunctionPass("Stage XVI"));
+  addPass(createMachineGroundTruth_FunctionPass());
+  addPass(GroundTruth_ModulePass());
+
   AddingMachinePasses = false;
 }
 
@@ -858,16 +891,20 @@
 
   // PreRA instruction scheduling.
   addPass(&MachineSchedulerID);
+  addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaX"));
 
   if (RegAllocPass) {
     // Add the selected register allocation pass.
     addPass(RegAllocPass);
+    //addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaXI"));
 
     // Allow targets to change the register assignments before rewriting.
     addPreRewrite();
+    //addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaXII"));
 
     // Finally rewrite virtual registers.
     addPass(&VirtRegRewriterID);
+    addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaXIII"));
 
     // Perform stack slot coloring and post-ra machine LICM.
     //
@@ -874,11 +911,13 @@
     // FIXME: Re-enable coloring with register when it's capable of adding
     // kill markers.
     addPass(&StackSlotColoringID);
+    addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaXIV"));
 
     // Run post-ra machine LICM to hoist reloads / remats.
     //
     // FIXME: can this move into MachineLateOptimization?
     addPass(&PostRAMachineLICMID);
+    addPass(createMachineCallsiteTestAugment_FunctionPass("Stage IVaXV"));
   }
 }
 
Index: Linker/LinkModules.cpp
===================================================================
--- Linker/LinkModules.cpp	(revision 300780)
+++ Linker/LinkModules.cpp	(working copy)
@@ -581,6 +581,7 @@
 bool Linker::linkModules(
     Module &Dest, std::unique_ptr<Module> Src, unsigned Flags,
     std::function<void(Module &, const StringSet<> &)> InternalizeCallback) {
+  errs() << "Linking " << Src->getModuleIdentifier() << " into " << Dest.getModuleIdentifier() << "\n";
   Linker L(Dest);
   return L.linkInModule(std::move(Src), Flags, std::move(InternalizeCallback));
 }
Index: Target/X86/CMakeLists.txt
===================================================================
--- Target/X86/CMakeLists.txt	(revision 300780)
+++ Target/X86/CMakeLists.txt	(working copy)
@@ -52,6 +52,7 @@
   X86EvexToVex.cpp
   X86MCInstLower.cpp
   X86MachineFunctionInfo.cpp
+  X86MachineGroundTruth.cpp
   X86MacroFusion.cpp
   X86OptimizeLEAs.cpp
   X86PadShortFunction.cpp
Index: Target/X86/X86.h
===================================================================
--- Target/X86/X86.h	(revision 300780)
+++ Target/X86/X86.h	(working copy)
@@ -89,6 +89,9 @@
 /// the upper portions of registers, and to save code size.
 FunctionPass *createX86FixupBWInsts();
 
+FunctionPass *createX86MachineGroundTruth_FunctionPass();
+FunctionPass *createX86MachineCallsiteAugment_FunctionPass();
+
 void initializeFixupBWInstPassPass(PassRegistry &);
 
 /// This pass replaces EVEX ecnoded of AVX-512 instructiosn by VEX 
Index: Target/X86/X86ExpandPseudo.cpp
===================================================================
--- Target/X86/X86ExpandPseudo.cpp	(revision 300780)
+++ Target/X86/X86ExpandPseudo.cpp	(working copy)
@@ -164,6 +164,7 @@
 
     MachineInstr &NewMI = *std::prev(MBBI);
     NewMI.copyImplicitOps(*MBBI->getParent()->getParent(), *MBBI);
+    NewMI.setCallSite(MBBI->getCallSite());
 
     // Delete the pseudo instruction TCRETURN.
     MBB.erase(MBBI);
Index: Target/X86/X86InstrInfo.cpp
===================================================================
--- Target/X86/X86InstrInfo.cpp	(revision 300780)
+++ Target/X86/X86InstrInfo.cpp	(working copy)
@@ -7676,8 +7676,11 @@
                                      const TargetInstrInfo &TII) {
   // Create the base instruction with the memory operand as the first part.
   // Omit the implicit operands, something BuildMI can't do.
+  errs() << MF.getName() << " MachineFunction::CreateMachineInstr() X86 - I\n";
   MachineInstr *NewMI =
       MF.CreateMachineInstr(TII.get(Opcode), MI.getDebugLoc(), true);
+  NewMI->setCallSite(MI.getCallSite());
+
   MachineInstrBuilder MIB(MF, NewMI);
   addOperands(MIB, MOs);
 
@@ -7704,8 +7707,11 @@
                               MachineInstr &MI, const TargetInstrInfo &TII,
                               int PtrOffset = 0) {
   // Omit the implicit operands, something BuildMI can't do.
+  errs() << MF.getName() << " MachineFunction::CreateMachineInstr() X86 - II\n";
   MachineInstr *NewMI =
       MF.CreateMachineInstr(TII.get(Opcode), MI.getDebugLoc(), true);
+  NewMI->setCallSite(MI.getCallSite());
+
   MachineInstrBuilder MIB(MF, NewMI);
 
   for (unsigned i = 0, e = MI.getNumOperands(); i != e; ++i) {
@@ -8626,6 +8632,7 @@
   }
 
   // Emit the data processing instruction.
+  errs() << MF.getName() << " MachineFunction::CreateMachineInstr() X86 - III\n";
   MachineInstr *DataMI = MF.CreateMachineInstr(MCID, MI.getDebugLoc(), true);
   MachineInstrBuilder MIB(MF, DataMI);
 
Index: Target/X86/X86MCInstLower.cpp
===================================================================
--- Target/X86/X86MCInstLower.cpp	(revision 300780)
+++ Target/X86/X86MCInstLower.cpp	(working copy)
@@ -47,6 +47,7 @@
 #include "llvm/Support/ELF.h"
 #include "llvm/Target/TargetLoweringObjectFile.h"
 
+
 using namespace llvm;
 
 namespace {
@@ -1255,6 +1256,84 @@
   return Comment;
 }
 
+namespace {
+
+static bool callsiteOpcodeCheck(MachineInstr const& MI)
+{
+  switch(MI.getOpcode())
+  {
+    case X86::CALLpcrel32: errs() << "X86::CALLpcrel32:\n"; break;
+    case X86::CALLpcrel16: errs() << "X86::CALLpcrel16:\n"; break;
+    case X86::CALL16r: errs() << "X86::CALL16r:\n"; break;
+    case X86::CALL16m: errs() << "X86::CALL16m:\n"; break;
+    case X86::CALL32r: errs() << "X86::CALL32r:\n"; break;
+    case X86::CALL32m: errs() << "X86::CALL32m:\n"; break;
+    case X86::FARCALL16i: errs() << "X86::FARCALL16i:\n"; break;
+    case X86::FARCALL32i: errs() << "X86::FARCALL32i:\n"; break;
+    case X86::FARCALL16m: errs() << "X86::FARCALL16m:\n"; break;
+    case X86::FARCALL32m: errs() << "X86::FARCALL32m:\n"; break;
+    case X86::CALL64pcrel32: errs() << "X86::CALL64pcrel32:\n"; break;
+    case X86::CALL64r: errs() << "X86::CALL64r:\n"; break;
+    case X86::CALL64m: errs() << "X86::CALL64m:\n"; break;
+    case X86::FARCALL64: errs() << "X86::FARCALL64:\n"; break; 
+   default:
+      return false;
+  }
+  return true;
+}
+
+static bool isIndirCS(ImmutableCallSite &CS)
+{ 
+  if (!CS.isCall())
+    return false;
+  
+  if (CS.getCalledFunction() || !CS.getCalledValue())
+    return false;
+  
+  Instruction const *I = CS.getInstruction();
+  if (CallInst const *CI = dyn_cast<CallInst>(I)) {
+    if (CI->isInlineAsm())
+      return false;
+  }
+  if (isa<Constant>(CS.getCalledValue()))
+    return false;
+  
+  return true;
+}
+
+static void indirCallSiteCheck(MachineInstr const& MI, MachineBasicBlock const& MBB, MachineFunction const& MF) {
+  if (!callsiteOpcodeCheck(MI))
+    return;
+
+  auto F = MF.getFunction();
+
+  if (auto bb = MBB.getBasicBlock()) {
+    for (auto const& instr : *bb) {
+      ImmutableCallSite cs(&instr);
+
+      if (isIndirCS(cs)) {
+        if (!cs.isMustTailCall()) {
+          errs().write_escaped(F->getName()) << "; ";
+          errs() << ("<CGCS>") << "; ";
+
+          auto site_arguments = 0;
+
+          for (auto const &arg : cs.args()) {
+            errs() << (*arg->getType()) << "; ";
+            site_arguments++;
+          }
+          for (auto i = site_arguments; i < 6; ++i)
+            errs() << "; ";
+
+          errs() << "parameter_count " << site_arguments << ";";
+          errs() << "return_type " << (*cs.getType()) << ";" << '\n';
+        }
+      }
+    }
+  }
+}
+}
+
 void X86AsmPrinter::EmitInstruction(const MachineInstr *MI) {
   X86MCInstLower MCInstLowering(*MF, *this);
   const X86RegisterInfo *RI = MF->getSubtarget<X86Subtarget>().getRegisterInfo();
@@ -1756,6 +1835,7 @@
   // in to the stackmap shadow.  The only way to achieve this is if the call
   // is at the end of the shadow.
   if (MI->isCall()) {
+    //indirCallSiteCheck(*MI, *(MI->getParent()), *MF);
     // Count then size of the call towards the shadow
     SMShadowTracker.count(TmpInst, getSubtargetInfo(), CodeEmitter.get());
     // Then flush the shadow so that we fill with nops before the call, not
Index: Target/X86/X86TargetMachine.cpp
===================================================================
--- Target/X86/X86TargetMachine.cpp	(revision 300780)
+++ Target/X86/X86TargetMachine.cpp	(working copy)
@@ -457,4 +457,6 @@
     addPass(createX86FixupLEAs());
     addPass(createX86EvexToVexInsts());
   }
+
+  addPass(createX86MachineGroundTruth_FunctionPass());
 }
