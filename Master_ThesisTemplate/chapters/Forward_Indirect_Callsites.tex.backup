\chapter{Forbidden C++ Forward Indirect Calls Exposed}
\label{C++ Bad Forward Indirect Calls}

\section{Polymorphism in C++}
\label{Late Binding in C++}
Polymorphism along inheritance and encapsulation
are the most used modern object-oriented concepts
in C++. 
Polymorphism in C++ allows to access different types of objects 
through a common base class. A pointer of the type of the base object
can be used to point to object(s) which are derived from the base class.
In C++ there is:
\textit{a)} compile-time (or static, usually is implemented with templates), 
\textit{b)} run-time (dynamic, is implemented with inheritance and virtual functions), 
\textit{c)} ad-hoc polymorphism (e.g., if the range of actual types that can be used 
is finite and the combinations must be individually specified prior to use), and
\textit{d)} parametric polymorphism (e.g., if code is written without mention of any 
specific type and thus can be used transparently with any number of new types it
is called parametric polymorphism). 
The first two are implemented through early 
and late binding, respectively.
In C++, overloading concepts fall under the category of \textit{c)} and Virtual functions;
templates or parametric classes fall under the category of pure polymorphism.
C++ provides polymorphism through: 
\textit{i)} virtual functions,
\textit{ii)} function name overloading, and 
\textit{iii)} operator overloading. 
In this paper, we will be concerned with dynamic 
polymorphism---based on virtual functions (10.3 and 11.5 in 
ISO/IEC N3690~\cite{iso:iecN3690})---because these can be exploited to 
call: illegitimate vtables in the class hierarchy 
or fake vtables.
Virtual functions have several uses and issues associated, 
but for the scope of this paper will look at the indirect 
call sites which are generated when objects are invoking these type
of functions. More precisely, 
\textit{1)} load-time enforcement: as calling each indirect call site (callee) requires 
a fix number of parameters which are passed each time the caller is calling, we
enforce a fine-grained CFI policy which checks the number and types of all function parameter
that belong to a indirect call site.
\textit{1)} run-time verification:



allows an object of one type to access



Explain how late binding is implemented in C++ and which role virtual functions play.
How is late binding basically implemented.

There is compile time Polymorphism and there is run time polymorphism.
Compile time polymorphism is realized through early binding and run time
polymorphism is realized through late binding.

\begin{minted}[
% frame=lines,
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray,
% fontsize=\footnotesize,
linenos
]{C++}
class SVGElement: public Element { ... }; 

Element *pDom = new Element();
SVGElement *pCanvas = new SVGElement();

// (1) valid upcast from pCanvas to pEle
Element *pEle = static_cast<Element*>(pCanvas);

// (2) valid downcast from pEle to pCanvasAgain (== pCanvas)
SVGElement *pCanvasAgain = static_cast<SVGElement*>(pEle);

// (3) invalid downcast (-> undefined behavior)
SVGElement *p = static_cast<SVGElement*>(pDom);

// (4) leads to memory corruption
p->m_className = "my-canvas";

// (5) invalid downcast with dynamic_cast, but no corruption
SVGElement *p = dynamic_cast<SVGElement*>(pDom);

if (p) {
p->m_className = "my-canvas";
}
\end{minted}

\section{Virtual Dispatch in Practice}
\label{Virtual Dispatch in Practice}

\section{Security Implications of Forbidden C++ Forward Indirect Calls}
\label{Security Implications of Virtual Dispatch}

How can Forbidden C++ Forward Indirect Calls exploited?
First through COOP attacks,
vptr corruption and then fake vtable insertion an reuse
or reuse of avaialble v tables.

Second, the available vtables in a large class hierarchy can represent 
another attack surface since a sufficiently large class hierarchy can provide
many useful gadgets for an attacker.

\section{Running Example: CVE X}
\label{Running Example: CVE X}
CVE-2014-3176


show the class hierarchy of the classes involved in the exploit.
Draw also the associated v tables along the classes.







