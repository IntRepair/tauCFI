\part{Snippets} 

% \chapter{Snippet [AddressTaken]}

As of now we used the full set of possible calltargets, which is the set of addresses of all function entry basic blocks. To further restrict the possible calltargets per callsite, we explored the notion of incorporating an address taken analysis into our application. The notion is that any indirect control flow instruction might only target addresses that are considered {taken}. An Address is considered to be a {taken} address, if it is loaded to memory or a register usually this is a constant, {!optional! however it is also possible that simple calculations using multiplication and/or addition are used. We are not concerned with more complex calculations, because we have not observed compilers resorting to more complex methods and literature so far does agree \cite{ZhangSekar00}}.

Based on the notions of \cite{ZhangSekar00}, introduced several types of indirect control flow targets of which only {!shorthand! Code Pointer Constants (CK)} and {!shorthand! Computed Code Pointers (CC)} are of interest to us. The reason for that is that the others are usually the target of indirect jumps, however we are (as of now) only interested in callsites.

% \definition{!shorthand! Code Pointer Constants (CK)} { are, as the name suggests, code addresses in the binary that are computed during compile time. In \cite{ZhangSekar00} it is furthermore stated that they only consider thos addresses that point to instruction boundaries or are within the range of addresses of the current module. However, we restrict that even further to only the set of addresses that point to entry blocks of functions within our current module, as these are the only valid targets of function calls.}

{!optional!
\definition{!shorthand! Computed Code Pointers (CC)} { are, addresses that are computed during binary execution. In \cite{ZhangSekar00}  this set only contains targets to intraprocedural indirect jumps and is thus of no interest for us} }

Our approach of indentifying taken addresses is a two pronged approach. First, we iterate over the raw binary content of data segments additionally identifying possible dereferencable addresses. Second, we iterate over all instructions in functions within the disassembled binary.


% \section{step 1} We rely on Dyninst to tell us the boundaries of the .plt section {!todo! add more information here} and the .text section, which contain the executable part of the binary and thus are use to precheck any addresses that we might find in this step.

As suggested in \cite{ZhangSekar00}, we slide a {!todo!, how much byte ? 4 or 8 ? what happens on X86-64 compared to x86}window over the data sections of the binary (namely the .data, the .rodata and the .dynsym).



% \section{step 2}
We rely on Dyninst \cite{dyninst00} to supply us with the correct function bounadries and addresses of instructions, which we then pass onto our instruction decoder, which is based on DynamoRIO. In essence there are types of analysis that are performed on each instruction. First we identify all relevant constants from the instruction
\begin{enumerate}
\item If the instructions is a control flow instructions, we completely ignore it, as it cannot give us any information that is relevant. {!todo! can we trace back from memory addresses and registers, what essentially is being called ?}
\item We look a the sources and {!todo! targets} of the instructions and add it to the list of potentially interesting targets
\item If the target is a RIP-based address, we rely on DynamoRIO to decode it and also add it to the list of potentially interesting target

\item {!todo what is with constant functions ?}
\item {!todo! can we have DynamoRIO infer the result of simple lea instructions ?}
\end{enumerate}

Then for the resulting set of addresses, we check whether each either point to the entry block of a function, points within the .plt section, or is present in our reference map, which we calculated earlier. {!todo! is the reference map needed ?}
