\chapter{TypeShild Overview}
\label{chapter:TypeShild Overview}

after the Design and Implementation section is done
we pick the most important points of TypeShild design and Implementation and describe them here.
The goal of this section is to be an appetizer for the whole design and Implementation section.
Which are usually dry (trocken).m

\section{1. Select Important Point from Design Chapter}
\section{2. Select Important Point from Design Chapter}
\section{3. Select Important Point from Design Chapter}

\section{Adversary Model}
\label{Adversary Model}

We consider a powerful, yet realistic adversary model that
is consistent with previous work on code-reuse attacks and
mitigations [give COOP reference here]. We rely on several existing
and complementary mitigations for comprehensive coverage.

Adversarial Capabilities.
 1. System Conguration: The adversary is aware of
the applied defenses and has access to the source and
non-randomized binary of the target application.


2. Vulnerability: The target application suffers from a
memory corruption vulnerability that allows the adversary
to corrupt memory objects. We assume that the
attacker can exploit this
aw to read from and write
to arbitrary memory addresses.


3. Scripting Environment: The attacker can exploit
a scripting environment to process memory disclosure information at run time, adjust the attack payload, and
subsequently launch a code-reuse attack.

B. Defensive Requirements.
1. Writable Executable Memory: The target system
ensures that memory can be either writable or
executable, but not both. This prevents an attacker
from either injecting new code or modifying existing
executable code.

2. Execute-only Memory: We build on previous systems
which enforce execute-only memory pages, i.e., the
CPU can fetch instructions but normal read or write
accesses trigger an access violation. See Section 5.2 for
further discussion of this component.

3. JIT Protection: We assume mitigations are in place
to prevent code injection into the JIT code cache and
prevent reuse of JIT compiled code [11, 18, 36]. These
protections are orthogonal to Readactor++.

4. Brute-forcing Mitigation: We require that the protected
software does not automatically restart after
hitting a booby trap which terminates execution. In
the browser context, this may be accomplished by displaying
a warning message

this section is just an example from the typearmor paper, of course we can 
replace it with our one but we need to address roughly the same points, namely
how TypeShild defends against COOP.

example from coop paper:

In general, code reuse attacks against C++ applications
oftentimes start by hijacking a C++ object and its vptr.
Attackers achieve this by exploiting a spatial or temporal
memory corruption vulnerability such as an overflow in a
buffer adjacent to a C++ object or a use-after-free condition.
When the application subsequently invokes a virtual function
on the hijacked object, the attacker-controlled vptr is deref-
erenced and a vfptr is loaded from a memory location of the
attacker’s choice. At this point, the attacker effectively controls
the program counter (rip in x64) of the corresponding thread
in the target application. Generally for code reuse attacks,
controlling the program counter is one of the two basic
requirements. The other one is gaining (partial) knowledge on
the layout of the target application’s address space. Depending
on the context, there may exist different techniques to achieve
this [8], [28], [44], [48].
For COOP, we assume that the attacker controls a C++
object with a vptr and that she can infer the base address of
this object or another auxiliary buffer of sufficient size under
her control. Further, she needs to be able to infer the base
addresses of a set of C++ modules whose binary layouts are
(partly) known to her. For instance, in practice, knowledge on
the base address of a single publicly available C++ library in
the target address space can be sufficient.
These assumptions conform to the attacker settings of most
defenses against code reuse attacks. In fact, many of these
defenses assume far more powerful adversaries that are, e. g.,
able to read and write large (or all) parts of an a

\section{TypeShild: Invariants for Targets and Callsites}
\label{TypeShild: Invariants for Targets and Callsites}
this section is just an example from the typearmor paper, of course we can 
replace it with our one but we need to address roughly the same points, namely
how TypeShild defends against COOP.

\section{TypeShild Impact on COOP}
\label{TypeShild Impact on COOP}
this section is just an example from the typearmor paper, of course we can 
replace it with our one but we need to address roughly the same points, namely
how TypeShild defends against COOP.

