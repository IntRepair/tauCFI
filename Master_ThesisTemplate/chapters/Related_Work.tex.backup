\chapter{Related Work}
\label{chapter:Related_Work}
In this section we shortly review the main techniques and tools which are related 
to \textit{TypeShild}. 
Section~\ref{Mitigation of Advanced Code-Reuse Attacks} presents 
several techniques which can not fully defend against advanced CRAs.
Section~\ref{Tyepe-Inference on Executables} gives an overview of tools used to
recover type inference from binaries.
Section~\ref{Binary-based Protection against COOP} highlights several tools which can
mitigate against the COOP attack on the binary level.
Section~\ref{Source Code based Protection agaisnt COOP} presents tools which can
mitigate against the COOP source code level.
Finaly, section~\ref{Runtime-based Protection against COOP} shows some of the most promissing 
runtime-based mitigation techniques against COOP.

\section{Mitigation of Advanced Code-Reuse Attacks}
\label{Mitigation of Advanced Code-Reuse Attacks}

COOP~\cite{schuster:coop}, Subversive-C~\cite{subversive-c:lettner} and Recursive-COOP~\cite{trap:crane} 
are advanced CRAs since these attacks:
\textit{i)} can not be addressed with shadow stacks techniques (i.e., do not violate the caller/calle convention), 
\textit{ii)} coarse-grained CFI techniques are useless against these attacks, 
\textit{iii)} hardware based approaches such as Intel CET~\cite{intel:cet} can not mitigate this attack for the same reason as in \textit{i)}, and 
\textit{iv)} OS-based approaches such as Windows Control Flow Guard~\cite{windows:cfguard} 
does not defend against COOP since the precomputed CFG does not contain edges for indirect call sites which are explicitly exploited
during the COOP attack.

CRAs have many manifestations and it is out of scope of this work to list them all here.
CRAs can be addressed in general the following ways: 
\textit{(i)} binary instrumentation,
\textit{(ii)} source code recompilation and 
\textit{(iii)} runtime application monitoring.
While there is a pletora of tools and techniques which try to enforce CFI 
primitives in executables, source code and during runtime, we briefly list
few of them in order for the reader to get familiar with the solution landscape.
The approaches used to combat against CRAs are roughly based on the following techniques:
\textit{(a)} fine-grained CFI with hardware support, PathArmor~\cite{veen:cfi},
\textit((b)) coarse-grained CFI used for binary instrumentation, CCFIR~\cite{ccfir:zhang},
\textit{(c)} coarse-grained CFI based on binary loader, CFCI~\cite{cfci:zhang}
\textit{(d)} fine-grained code randomization, O-CFI~\cite{mohan:opaque},
\textit{(e)} cryptografy with hardware support, CCFI~\cite{ccfi:jose},
\textit{(f)} ROP stack pivoting, PBlocker~\cite{pblocker:prakash},
\textit{(g)} canary based protection, DynaGuard~\cite{dynaguard:petsios},
\textit{(h)} checking vTable integrity for protecting against COOP based on CFI for source code auch as SafeDispatch~\cite{safedispatch:jang}, vtv~\cite{vtv:tice} LLVM and GCC compiler based vor vTable protection and binary rewriting such as vfGuard~\cite{vfuard:aravind}, vTint~\cite{vtint:zhang} and~\cite{trap:crane},
\textit{(i)} runtime and hardware support based on a combination of LBR, PMU and BTS registers CFIGuard~\cite{cfiguard:yuan} and
\textit{(j)} source code recompilation with CFI and/or randomization enforcement against JIT-ROP attacks, MCFI~\cite{mcfi:niu}, RockJIT~\cite{rockjit:niu} and PiCFI~\cite{perinput:niu}.

Notice that the above techniques are useless against the aforementioned advanced CRAs,
the list is not exaustive and new protection technies arise by combining available techniques
or by using newly available hardware features.

\section{Tyepe-Inference on Executables}
\label{Tyepe-Inference on Executables}
Recovering variable types from executable programs
is very hard in general for several reasons. 
First, the quality of the disasembly can very much from used
framework to another. \textit{TypeShild} is based on DynInst 
and the quality of the execuatble disasembly fits our needs. 
For a more comprehensive review on the capabilities of DynInst and other tools we
advice the reader to have a look at~\cite{andriesse:indepth}.

Second, pointer deferece reconstruction from binares is undecidable~\cite{}.
There are several most promising tools such as: Rewards~\cite{lin:rewards}, BAP~\cite{bap:brumley}, 
SmartDec~\cite{fokin:smartdec}, and Divine~\cite{divine:balakrishnan}.
These tools try with more or less success to recover 
type information from binary programs with different goals.
Typical goals are: 
\textit{i)} full program reconstruction (binary to code convertion, reversing), 
\textit{ii)} checking for buffer overflows, 
\textit{iii)} integer overflows and other types of memory corruptions.
For a more exhaustive review of such tools we advice the reader to
have a look at the review of Caballero et al.~\cite{caballero:inference}.
Intresting to notice is that the code from only a few of this tools is available.


\section{Binary-based Protection against COOP}
\label{Binary-based Protection against COOP}
\textit{TypeShild} is most similar to TypeArmor~\cite{veen:typearmor} since
we also enforce strong binary-level invariants on the number of function
paramters. \textit{TypeShild} similarly to TypeArmor targets 
exclusive protection against advanced exploitation techniques 
which can bypass fine-grained CFI schemes and VTable protections at the binary level.

However, \textit{TypeShild} is much more precise than TypeArmor since its enforcing 
policy is also based on the types of the function parameters. This results in a
more precise selection of caller/calle pairs on which the fine-grained CFI policy is enforced.
Thus, we achieve a reduced runtime overhead than TypeArmor since we enfoce 
our CFI policy on fewer caller/callee pairs than TypeArmor.

\section{Source Code based Protection against COOP}
\label{Source Code based Protection agaisnt COOP}
There are several source code based tools 
which can succesfully protect against the COOP attack.
Such tools are: ShrinkWrap~\cite{haller:shrinkwrap}, IFCC/VTV~\cite{vtv:tice}, 
SafeDispatch~\cite{safedispatch:jang}, vTrust~\cite{zhang:vtrust}, Readactor++~\cite{crane:readactor++}, CPI~\cite{volodymyr:cpi} and the
tool presented by Bounov et al.~\cite{bounov:interleaving}. These tools profit from high precision
since they have access to the full semantic context of the program though the scope
of the compiler on which they are based. 
Because of this reason these tools target mostly other types of security problems than binary-based 
tools address. For example some last advancec in compile based protection against 
code reuse attacks address mainly performance issues.
Currently, most of the above presented tools are only forward
edge enforcers of fine-grained CFI policies with an overhead from 1\% up to 15\%.

We are aware that there is still a long research path to go until binary based techniques can 
recuperate program based semantic information from executable with the same precision as compiler based tools.
These path could be even endless since compilers are optimized for speed and are designed to remove as much as possbile semantic information
from an executable in order to make the program run as fast as possible. In light of this fact,
\textit{TypeShild} is another attempt to recuperate just the needed semantic information (types and number of function parameters from
indirect call sites) in order to be able to enforce a precise and with low overhead primitive against COOP attacks.

Rather than claiming that the invariants offered by \textit{TypeShild} are suffiecient
to mitigate all versions of the COOP attack we take a more conservative path by claiming that \textit{TypeShild} 
further raises the bar w.r.t. what is possible when defending against COOP attacks on the binary level.

\section{Runtime-based Protection against COOP}
\label{Runtime-based Protection against COOP}
\textit{There is something available out there but I can not used it: anonymus}.
Long story short conclusion: There are several promissing runtime-based line of defenses against
advanced CRAs but none of them can succesfully protect against the COOP attack.

IntelCET~\cite{intel:cet} is based on, \texttt{ENDBRANCH}, a new CPU instruction which can be used to enforce
an efficient shadow stack mechanism. The shadow stack can be used to check during program execution if caller/return pais match.
Since the COOP attack reuses whole functions as gadgets and does not violate the caller/return convention than the 
new feature provided by interl is useless in the face of this attack. Nevertheless other highly notorious CRAs may not be possible
after this feature will be implemented main stream in OSs and compilers.

Windows Control Flow Guard~\cite{windows:cfguard} is based on a user-space and kernel-space components which
by working closelly together can enforce an efficient fine-grained CFI policy based on a precomputed CFG.
These new feature available in Windows 10 can considerably rise the bar for future attacks but in our opinion advanced CRAs
such as COOP are still possible due the typical characteristics of COOP.

PathArmor~\cite{veen:cfi} is yet another tool which is based on a precomputed CFG and on the LBR register which can give a string of 16 up to
32 pairs of from/to addressed of different types of indirect instructions such as \texttt{call}, \texttt{ret}, and \texttt{jump}. 
Because of the sporadic query of the LBR register (only during invocation of certain function calls) and because of the sheer amount of 
data which passes thorugh the LBR register this apporach has in our opinion a fair potential to catch different types of CRAs but
we think that against COOP this tool can not be used. First, because of the fact that the precomputed CFG does not contain edges for all
possible indirect call sites which are accessed during runtime and second, the LBR buffer can be easily triked by adding
legitimate indirect call sites  during the COOP attack.

