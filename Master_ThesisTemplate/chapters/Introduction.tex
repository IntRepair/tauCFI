\chapter{Introduction}
\label{chapter:Introduction}
Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} is one of the most used techniques
to secure program execution flows against advanced Code-Reuse Attacks (CRAs).

Advanced CRAs such as COOP~\cite{schuster:coop}

Present the virtual function concept in C++, What does it is good for and what security implications does it have?

Talk about the security implications of vptr corruptions and give some CVEs numbers here.

Briefly talk about source code based solutions which protect against vptr corruptions and n the 
end against COOP. Talk about SafeDispatch, ShrinkWrap, Bounov et al, IFCC/VTV etc.


Give a presentation of TypeArmor

TypeArmor~\cite{veen:typearmor} is a run-time based
tool which enforces a fine-grained forward edge policy
in executables based on caller/callee matching based on 
parameter count. 

The introduction should answer this questions:

1.What is the problem? 
There are no mechanisms in C++ implemented which check during late binding
(realized through virtal call sited, indirect call sites in binaries) that
the target of an indirect call site is legitimate or illegitimate.

Specify The Problem statement. 
In this thesis we want to develop a tool which can mitigate one 
of the most dangerous attack which exploits the missing security checks from above.

2.What are the current solutions?
There are three lines of defence against COOP attacks, source code based,
binary based and runtime based (thre is no real application which can really defend against).

TypeArmor~\cite{veen:typearmor} is the most similar tool to \textit{TypeShild} and it used
function parameter coundting by enforcing a fine-grained policy on valid indirect caller/callee pairs
inside a binary. The policy is checked during run-time by cheching that the number of parameters which 
an indirect call site provides matches with the number of parameter the calle expects. This invariant
helps to defend against COOP and Control Flow Jujutsu.

\todo[inline]{@Matthias: add some limitations of type Armor.}

3.Where the solutions lack?
TypeArmor lacks in precision w.r.t. caller/calle matching since it relies only on parameter counting.

4.What is your idea?
Our insight is to enforce a fine-grained CFI policy by combining function parameter count, type matching.
This offers higher precision than TypeArmot and probably higher performance than TypeArmor has since we 
add less checks in the binary. Thus checking fewer checks in the binary results in a better performance 
overhead than comparable solutions.

5.Contributions.
In summary, we make the following contributions:
See contribution section, down.

% \begin{enumerate}
%  \item We did this 
%  
%  \item We did this 
%  
%  \item We did this.
%  
%  The rest of the MA is organized as follows.
%  
% \end{enumerate}

\section{Motivation}
\label{Motivation}

this should be up to a din A4 page, example (remove afterwards):
\todo[inline]{@Matthias: remove and add your motivation}

The development of various defense mechanisms, such as the introduction of data
execution prevention (DEP) [18], stack smashing protection (SSP) [13], and address
space layout randomization (ASLR) [42], have raised the bar for reliable exploit devel-
opment significantly. Nevertheless, a dedicated attacker is still able to achieve code
execution [33, 25]. Information leaks are utilized to counter ASLR and reveal the lay-
out of the address space or other valuable information [40, 33]. To circumvent DEP
the attackers have added code-reuse attacks, such as return-oriented programming
(ROP) [39, 9, 26], jump-oriented programming (JOP) [16, 11, 5], and call-oriented
programming (COP) [10], to their repertoire. Code-reuse attacks do not inject new
code but chain together small chunks of existing code, called gadgets, to achieve ar-
bitrary code execution.
In response to this success, the defensive research was driven to find protection
methods against code-reuse attacks. Some results of this research are kBouncer [32],
ROPecker [12], EMET [19]/ROPGuard [21], BinCFI [53], and CCFIR [52]. These
defenses incorporate two main ideas. The first is to enforce control-flow integrity
(CFI) [1, 2]. With perfect CFI the control-flow can neither be hijacked by code-
injection nor by code-reuse [22]. However, the overhead of perfect CFI is too high
to be practical. Therefore the proposed defense methods try to find the sweet spot
between security and tolerable overhead. The second idea is to detect code-reuse at-
tacks by known characteristics of an attack like a certain amount of gadgets chained
together. All of those schemes defend attacks on the x86/x86-64 architecture. For
other architectures the research is lacking behind [15].
Several generic attack vectors have been published by the offensive side to high-
light the limitations of the proposed defense methods. Although single implementa-
tions can be disabled with common code-reuse attacks by exploiting a vulnerability
in the implementation [14, 7], the generic ones rely on longer and more complex
gadgets [22, 17, 37, 10, 23]. Since the gadgets loose their simplicity by becom-
ing longer it also becomes harder to find specific gadgets and chain them together.
To our knowledge there is no gadget finder available to search CFI resistant gad-
gets.

\section{Contribution}
\label{Contribution}
example remove afterwards:

The objective of this thesis is to develop a tool that assists the exploit developer at
locating gadgets which circumvent CFI and heuristic checks. All changes to registers
and memory space must be immediately evident to the exploit developer. For this
reason, we analyze the gadgets and categorize every register and every memory write
by a set of semantic definitions. We use an IL for the analysis to support different
architectures without the effort of adjusting the algorithms to new architectures.
Because of the high architecture coverage, VEX [44] is our choice for the IL. VEX is
part of Valgrind, an instrumentation framework intended for dynamic use [43]. To
use VEX statically pyvex [51] is utilized. We instrument the SMT solver Z3 [48]
for the analysis itself. Unfortunately, there is no interface from VEX or pyvex to
Z3 available. Hence, we develop a translation from VEX to Z3. A wrapper adds
the architecture layouts to Z3, thus making Z3 suitable for symbolic execution and
path constrain analysis of the gadgets. To sum up, our thesis makes the following
contributions:
1. We develop a tool to discover CFI and heuristic check resistant gadgets in an
architecture independent offline search.

2. We provide semantic definitions for a convenient search of the gadgets.

3. We provide a modular translation unit from VEX/pyvex to Z3, including a
symbolic execution engine implemented for x86, x86-64, and ARM.

\section{Outline}
\label{Outline}
The remainder of this thesis is organized as follows.
We start by giving an overview of how \textit{TypeShild}
is designed to mitigate COOP attacks. 
Chapter~\ref{C++ Bad Forward Indirect Calls} gives an overview of bad C++
forward edge calls and its security implications.
Chapter~\ref{chapter:TypeShild Overview} contains an high level overview of \textit{TypeShild}.
Chapter~\ref{chapter:Design} gives an overview of the techniques
used in \textit{TypeShild}.
Chapter~\ref{chapter:Implementation} presents briefly the implementation
details of our tool.
The \textit{TypeShild} implementation is evaluated and discussed in
Chapter~\ref{chapter:Evaluation} and Chapter~\ref{chapter:Discussion}, respectively.
Chapter~\ref{chapter:Related_Work} surveys related work.
Finally, Chapter~\ref{chapter:Future_Work} highlights several future steps and
Chapter~\ref{chapter:Conclusion} concludes this thesis.


