\section{Implementation}
\label{chapter:Implementation}

We implemented \textsc{TypeShield} using the instrumentation framework (v.9.2.0). We currently restricted our analysis and instrumentation to x86-64 
bit elf binaries using the SystemV call convention, because the DynInst library does not yet support the
Windows platform. However, there is ongoing work to allow DynInst to work with Windows binaries as well. We focused on the SystemV call 
convention as most C/C++ compilers on Linux implement this ABI, however, we encapsulated most ABI-dependent behavior, so it should be 
possible to implement other ABIs with relative ease. Therefore, we deem it possible to implement \textsc{TypeShield} for the Windows 
platform in the near future, as we do not use any other platform-dependent APIs. We developed the core part of our pass in an instruction
analyzer, which relies on the DynamoRIO~\cite{dynamorio:drmemory} library (v.6.6.1) to decode single instructions and provide access to
its information. The analyzer is then used to implement our version of the reaching and liveness analysis (similar to PathArmor~\cite{veen:typearmor}), 
which can be customized with relative ease, as we allow for arbitrary path merging functions. We implemented a 
Clang/LLVM (v.4.0.0, trunk 283889) pass used for 
collecting ground truth data in order to measure the quality and performance of our tool. The ground truth data is then used to verify 
the output of our tool for several test targets. This is accomplished with the help of our Python-based evaluation and test environment. 
In total, we implemented \textsc{TypeShield} in 5501 lines of code (LOC) of C++ code, our Clang/LLVM pass in 416 LOC
of C++ code and our test environment in 3239 Python LOC. 


