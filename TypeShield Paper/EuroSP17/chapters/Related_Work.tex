\section{Related Work}
\label{chapter:Related_Work}

% \subsection{Type-Inference on Executables}
% \label{Type-Inference on Executables}
% Recovering variable types from executable programs
% is very hard in general for several reasons. 
% First, the quality of the disassembly can vary much from used
% framework to another. \textsc{TypeShield} is based on DynInst 
% and the quality of the executable disassembly fits our needs. 
% For a more comprehensive review on the capabilities of DynInst and other tools we
% advice the reader to have a look at~\cite{andriesse:indepth}.
% Second, alias analysis in binaries is undecidable in theory and intractable in practice~\cite{alan:mycroft}.
% There are several most promising tools such as: Rewards~\cite{lin:rewards}, BAP~\cite{bap:brumley}, 
% SmartDec~\cite{fokin:smartdec}, and Divine~\cite{divine:balakrishnan}.
% These tools try with more or less success to recover 
% type information from binary programs with different goals.
% Typical goals are: 
% (i) full program reconstruction (\textit{i.e.,} binary to code conversion, reversing, etc.), 
% (ii) checking for buffer overflows, and
% (iii) integer overflows and other types of memory corruptions.
% For a more exhaustive review of such tools we advice the reader to
% have a look at the review of Caballero \textit{et al.}~\cite{caballero:inference}.
% Interesting to notice is that the code from only a few of these tools is actually available.
% 
% SmartDec seemed at first promising due to its simple type lattice that we wanted to leverage for our classification schema. 
% Its integration into our DynInst based environment was not successful mostly for several reasons, as it was deemed to 
% time consuming to extract the whole machinery and implement an interface to the DynInst disassembler.
% Therefore, we finally implemented our own version of function parameter type analysis and focused only
% on the wideness of the types, resulting in a simpler lattice than we initially intended.

% \subsection{Mitigation of Advanced CRAs}
% \textbf{Mitigation of Forward-Edge based Attacks.}
% \subsection{Mitigation of Forward-Edge based Attacks.}
% \label{Mitigation of Advanced Code-Reuse Attacks}
% Recursive-COOP~\cite{crane:readactor++}, COOP~\cite{schuster:coop}, Subversive-C~\cite{subversive-c:lettner} and the attack of Lan \textit{et al.}~\cite{loop:oriented} are 
% forward-edge based CRAs which cannot be addressed with:
% (i)  shadow stacks techniques and hardware-based approaches such as Intel CET~\cite{intel:cet} (\textit{i.e.,} since advanced COOP do not violate 
% the caller/callee convention), 
% (ii) coarse-grained Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} techniques, and 
% (iii) OS-based approaches such as Windows Control Flow Guard~\cite{windows:cfguard} 
% since the precomputed CFG does not contain edges for indirect callsites which are explicitly exploited during the COOP attack.

\subsubsection{Forward-edge Based Binary Tools}
% The following tools address vTable protection through binary instrumentation, 
% but fail to mitigate against COOP: vfGuard~\cite{vfuard:aravind}, and vTint~\cite{vtint:zhang}.

TypeArmor~\cite{veen:typearmor} is a binary instrumentation tool that can protect against COOP.
TypeArmor uses a fine-grained CFI policy based on caller/callee (but only indirect callsites) matching, which checks 
during runtime if the number of provided and needed parameters match.
\textsc{TypeShield} is related to TypeArmor~\cite{veen:typearmor}, since we also enforce strong binary-level 
invariants on the number of function parameters. Further, \textsc{TypeShield} also aims for exclusive protection 
against advanced exploitation techniques, which can bypass fine-grained CFI schemes and vTable protections at the 
binary level. However, \textsc{TypeShield} offers a better restriction of calltargets to callsites, since we not 
only restrict based on the number of parameters, but also on the width of their types. This results in much smaller 
buckets that in turn can only target a smaller subset of all address-taken functions. 
%However, we rely for that on the variety of parameter types and when there is none, we will degrade into a parameter count policy.

% We are aware that there is still a long research path to go until binary based techniques can 
% recuperate program based semantic information from executable with the same precision as compiler based tools.
% This path could be even endless since compilers are optimized for speed and are designed to remove as much as possible semantic information
% from an executable in order to make the program run as fast as possible. In light of this fact,
% \textsc{TypeShield} is another attempt to recuperate just the needed semantic information (types and number of function parameters from
% indirect callsites) in order to be able to enforce a precise and with low overhead primitive against COOP attacks.

VCI~\cite{vci:asiaccs} is a binary based tool (7.9\%) based on DynInst which can protect forward edge indirect control flow violations based 
on reconstructing a quasi program class hierarchy (\textit{i.e.,} no class root node and the edges are not directed). The authors claim that 
VCI is 10 times more precise w.r.t. reducing the calltarget set per callsite. In contrast to \textsc{TypeShield} VCI can not 
protect backward edge violations and we arguably due to the conservative analysis the VCI could skip some corner situations 
allowing not legitimate calltargets.

Marx~\cite{marx} is most similar to VCI and as VCI this tool reconstructs the same type of quasi program class hierarchy. 
No runtime efficiency numbers were provided in the paper.
The authors claim that Marx can recuperate a class hierarchy which is more precise than that of IDAPro. The paper is geared towards
first providing a tool which can be used by analyst in order to reverse engineer a binary. The precision of the calltarget set reduction
per callsite should be similar to those of VCI but no comparison was compared in the paper. Compared to \textsc{TypeShield} 
Marx can not protect against backward edge violations and arguably has in common with VCI several limitations.

% VTPin~\cite{vtpin} is a runtime based tool ($\approx$5\%) used for protecting against VTable hijacking, via use-after-free vulnerabilities. VTPin pins
% all the freed VTable pointers on a safe VTable under VTPin’s control. For each object deallocation, VTPin deallocates all space allocated, but preserves and updates
% the VTable pointer with the address of the safe VTable. As consequence a dangling pointer can invoke 
% invoke a method provided by VTPin’s safe object. TPin needs to keep track of meta-data in order to detect runtime 
% dangling pointer violations. The tool can not protect against the COOP attack since the COOP attack does not rely on dangling pointers.
% In contrast with \textsc{TypeShield} this tool can not protect against backward edges violations.

% In this paper, rather than claiming that the invariants offered by~\textsc{TypeShield} are sufficient
% to mitigate all versions of the COOP (as \cite{veen:typearmor} does) attack we conservatively claim that~\textsc{TypeShield} 
% further raises the bar w.r.t. what is possible when defending against COOP attacks on the binary level.

% \subsubsection{Source Code Based Techniques} Indirect callsite targets are checked based on vTable integrity.
% Different types of CFI policies are used such as in the following tools:
% SafeDispatch~\cite{safedispatch:jang}, IFCC/VTV~\cite{vtv:tice} LLVM and GCC compiler.
% Additionally, the Redactor++~\cite{crane:readactor++} uses randomization 
% vTrust~\cite{zhang:vtrust} checks calltarget function signatures, 
% CPI~\cite{volodymyr:cpi} uses a memory safety technique
% in order to protect against the COOP attack.
% 
% There are several source code based tools 
% which can successfully protect against the COOP attack.
% Such tools are: ShrinkWrap~\cite{haller:shrinkwrap}, IFCC/VTV~\cite{vtv:tice}, 
% SafeDispatch~\cite{safedispatch:jang}, vTrust~\cite{zhang:vtrust}, Readactor++~\cite{crane:readactor++}, CPI~\cite{volodymyr:cpi} and the
% tool presented by VTI~\cite{bounov:interleaving}. These tools profit from high precision
% since they have access to the full semantic context of the program trhough the scope
% of the compiler on which they are based. 
% Because of this reason, these tools target mostly other types of security problems than binary-based 
% tools address. For example, some of the last advancements in compiler based protection against code reuse attacks address mainly performance issues.
% Currently, most of the above presented tools are only forward edge enforcers of fine-grained CFI policies with 
% an overhead from 1\% up to 15\% (see \cite{cfi_survey_payer} for more details).
% 
% \subsubsection{Runtime Based Techniques}
% Several promising runtime-based defenses against advanced CRAs exist but currently none of them can successfully
% protect against the COOP attack.
% 
% IntelCET~\cite{intel:cet} is based on, \texttt{ENDBRANCH}, a new CPU instruction which can be used to enforce
% an efficient shadow stack mechanism. The shadow stack can be used to check during program execution if caller/return pairs match.
% Since the COOP attack reuses whole functions as gadgets and does not violate the caller/return convention than the 
% new feature provided by intel is useless in the face of this attack. Nevertheless, other highly notorious CRAs may not be possible
% after this feature will be implemented main stream in OSs and compilers.
% 
% Windows Control Flow Guard~\cite{windows:cfguard} is based on a user-space and kernel-space components which
% by working closely together can enforce an efficient fine-grained CFI policy based on a precomputed CFG.
% These new feature available in Windows 10 can considerably raise the bar for future attacks but in our opinion advanced CRAs
% such as COOP are still possible due the typical characteristics of COOP.
% 
% PathArmor~\cite{veen:cfi} is yet another tool which is based on a precomputed CFG and on the LBR register which can give a string of 16 up to
% 32 pairs of from/to addressed of different types of indirect instructions such as \texttt{call}, \texttt{ret}, and \texttt{jump}. 
% Because of the sporadic query of the LBR register (only during invocation of certain function calls) and because of the sheer amount of 
% data which passes through the LBR register this approach has in our opinion a fair potential to catch different types of CRAs but
% we think that against COOP this tool can be used only with limited success. 
% First, because of the fact that the precomputed CFG does not contain edges for all
% possible indirect callsites which are accessed during runtime. Second, the LBR buffer can be easily fooled by interleaving
% legitimate with illegitimate indirect callsites during the COOP attack.
% 
% % %maybe not relevant
% \subsection{Mitigation of not Advanced CRAs}
% \label{Mitigation of Code-Reuse Attacks}
% In the last couple of years researchers have provided many versions of new Code Reuse Attacks (CRAs).
% These new attacks were possible since DEP~\cite{dep} and ASLR~\cite{ASLR} were successfully bypassed mostly based
% on Return Oriented Programming (ROP)~\cite{ROP, kornau:rop, rop:shacham} on one hand and due to the discovery of 
% new exploitable hardware and software primitives, on the other hand.
% 
% ROP started to present itself in the last couple of years in many faceted ways such as:
% Jump Oriented Programming (JOP)~\cite{JOP1, JOP2, JOP3} which uses jumps in order to divert the control flow to the next gadget and 
% Call Oriented Programming (COP)~\cite{rop:carlini} which uses calls in order to chain gadgets together.
% CRAs have many manifestations and it is out of scope of this work to list them all.
% 
% First, CRAs can be mitigated in general in the following ways: 
% (i) binary instrumentation,
% (ii) source code recompilation and 
% (iii) runtime application monitoring.
% Second, there is a plethora of tools and techniques which try to enforce CFI based
% primitives in executables, source code and during runtime. Thus, we briefly
% present the solution landscape together with the approaches and the techniques on which these are based:
% (a) fine-grained CFI with hardware support, PathArmor~\cite{veen:cfi},
% (b) coarse-grained CFI used for binary instrumentation, CCFIR~\cite{ccfir:zhang},
% (c) coarse-grained CFI based on binary loader, CFCI~\cite{cfci:zhang}
% (d) fine-grained code randomization, O-CFI~\cite{mohan:opaque},
% (e) cryptography with hardware support, CCFI~\cite{ccfi:jose},
% (f) ROP stack pivoting, PBlocker~\cite{pblocker:prakash},
% (g) canary based protection, DynaGuard~\cite{dynaguard:petsios},
% (h) runtime and hardware support based on a combination of LBR, PMU and BTS registers CFIGuard~\cite{cfiguard:yuan}, and
% (i) source code recompilation with CFI and/or randomization enforcement against JIT-ROP attacks, MCFI~\cite{mcfi:niu}, 
% RockJIT~\cite{rockjit:niu} and PiCFI~\cite{perinput:niu}.
% 
% The above list is not exhaustive and new protection techniques can be obtained by combining available techniques
% or by using newly available hardware features or software exploits. However, notice that none of the above mentioned 
% techniques and tools can be used to mitigate COOP attacks.
% 

% \subsection{Mitigation of Backward-Edge based Attacks.}
\subsubsection{Backward-edge Based Binary Tools}
Backward-Edge based code reuse attacks exploit the indirection provided by the return instructions 
of a function. Usually each modern compiler builds caller/callee pairs by adhering to the so called caller-callee
calling convention. This calling convention basically specifies that for each indirect call the return address of the function which returns after 
it was called lies at the next address of the call instruction. 
This calling convention is violated by all ROP attacks and also by 
more recent advanced code reuse attacks. 
Intel CET~\cite{intel:cet} is a promising technology from Intel in which the X86 instruction set is updated with new instructions (\textit{i.e.,} \texttt{END\_BRANCH}) instruction
which should facilitate an efficient implementation of shadow stack implementations. Currently, this technology is not available and it is not foreseeable when this features will 
be available in mass production.
For brevity reasons we do not look herein into compiler and purely runtime techniques and advise the reader to look for 
more details the following survey~\cite{cfi_survey_payer}.

The CFI based implementation of Abadi et al.~\cite{abadi:cfi} is historically the first compiler based implementation of a shadow stack.
At first, quite promising this implementation suffers from high performance overhead which is around 21\% due to the fact that the inserted checks before each 
function return instruction are not runtime efficient.

% \subsubsection{Compiler Based Techniques}
% LLVM SafeStack~\cite{volodymyr:cpi} is a compiler based approach in which for each function stack a shadows stack copy is build with the help of the Clang compiler. These additional stacks
% are hidden by at least one level of indirection from the attacker such that she can not interfere with it. This approach is effective but suffers from a big binary blow-up which is not acceptable
% in any usage scenario. Currently, it was demonstrated that this implementation can be bypassed~\cite{safestack:bypassing}.
% 
% \subsubsection{Runtime Based Techniques}
% Windows CFGuard~\cite{windows:cfguard} is a technology by Microsoft deployed into Windows 8.1 and Windows 10. This technology allows to protect backward edges by checking in a 
% shadow stack like fashion for backward edge violations. The implementation is based on an interplay between user space and kernel space thus there is high potential that this 
% implementation is highly efficient even trough no official evaluation results are available.
% 
% PathArmor~\cite{veen:cfi} is a runtime based tool based on a Linux loadable module which can emulate shadow stack checks by using the \texttt{LBR} register which stores 
% callsite and target address pairs. The capacity of the LBR register is limited to 32 address pairs which can be stored. The tools sufferes from high runtime overhead and 
% it is imprecise since the address pairs can not be analyzed at the same speed as they arrive in this register. For this reason some pairs are skipped and thus the attacker has 
% the chance to mount and attack.
