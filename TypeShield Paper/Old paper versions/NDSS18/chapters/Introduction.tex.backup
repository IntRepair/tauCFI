\section{Introduction}
\label{chapter:Introduction}

% \textbf{Big Picture.}
The object-oriented programming (OOP) paradigm and the C++ programming language are the de facto standard for developing large, complex and efficient software systems, in particular, 
when runtime performance and reliability are primary objectives.

A key building block of (runtime) OOP polymorphism are virtual functions, which enable late binding and allow programmers to overwrite a virtual function of the base-class with their 
own implementations. In order to implement virtual functions, the compiler needs to generate a virtual table meta-data structure of all virtual functions for each class containing 
them and provide to each instance of such a class a (virtual) pointer to the aforementioned table. While this approach allows for more flexible code to be built, 
the basic implementation provides unfortunately very little security assurances. Data about highly damaging arbitrary code executions in major applications collected by U.S. NIST 
(see Figure~\ref{ace:nvd:statistics} description
and~\cite{NVD:ACE}) demonstrates the security shortcomings and the need to address this problem space.

\begin{figure}[t!]
\centering
\hspace{-.323cm}
  \includegraphics[scale=0.77]{figures/distri.pdf}
%   \node[below=of img, node distance=0cm, yshift=1.2cm, xshift=.25cm, font=\color{black}] {Year};
%   \node[left=of img, node distance=0cm, rotate=90, anchor=center,yshift=-.9cm,font=\color{black}] {\# Bad Type Casts Reported};
% \vspace{-.73cm}
% \vspace{-.2cm}
\caption{Arbitrary code reuse attacks vs. object corruptions.}
\label{ace:nvd:statistics}
\vspace{-.7cm}
\end{figure}

While the reasons for unwanted outcomes can be highly diverse, our work is primarily motivated by the presence of at least one exploitable
memory corruption (\textit{e.g.,} buffer overflow, etc.), which can enable the execution of sophisticated Code-Reuse Attacks (CRAs) such as the advanced COOP attack~\cite{schuster:coop} and its 
extensions~\cite{crane:readactor++, subversive-c:lettner, ctf:coop, loop:oriented}. A necessary ingredient for this class of attacks is the ability
to corrupt the virtual pointer of an object in order to call gadgets by using a list of fake objects.

To address such object dispatch corruptions\footnote{Number (\#, left side of Figure~\ref{ace:nvd:statistics}) and percentage (\%, right side of Figure~\ref{ace:nvd:statistics}) 
of arbitrary code executions (ACE) reports related (all colors expect black) to virtual pointer or virtual table (vptr/vtbl) corruption 
(see bag of words at the bottom of left Figure~\ref{ace:nvd:statistics})* reported by U.S. NVD for the past 10 years~\cite{NVD:ACE}. 
X axis is years (left \& right) and Y axis is number of reports in logarithmic scale (left, 204) and distribution in \% of the reports (right, 799).
In black are the ACE unrelated reports.
As of August'17, U.S. NVD reports in total 799 ACEs from which 204 are the result of a vptr/vtable corruption (see * above) that are exploited by highjacking forward indirect calls.
These vulnerabilities were reported in applications such as Google's Chrome \& V8 JavaScript engine, Mozilla Firefox, Microsoft's IE 10, Edge \& Chakra JavaScript engine, and iOS/MacOS apps.} 
and in general any type of indirect control flow transfer violation, Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} was originally developed to secure indirect control flow transfers by adding 
runtime checks before forward-edges and backward-edges. Unfortunately, COOP and its brethren bypass most deployed CFI-based enforcement policies, since 
these attacks do not exploit indirect backward-edges (\textit{i.e.,} function returns), but rather exploit the forward indirect control flow transfers (\textit{i.e.,} object dispatches)
imprecision which cannot be statically precisely determined upfront as alias analysis is undecidable~\cite{alias:undecidable} in program binaries.

More recent techniques and tools can be distinguished into those relying on \textit{source code} access including SafeDispatch~\cite{safedispatch:jang}, ShrinkWrap~\cite{haller:shrinkwrap}, 
VTI~\cite{bounov:interleaving}, and IFCC/VTV~\cite{vtv:tice}; the latter being used in production, but the reliance on source-code availability limits the applicability of the approach. 
In contrast, \textit{binary}-based tools typically rely on forward-edge CFI policies. Examples include binCFI~\cite{ccfir:zhang, zhang:usenix}, vfGuard~\cite{vfuard:aravind}, vTint~\cite{vtint:zhang}, 
VCI~\cite{vci:asiaccs}, Marx~\cite{marx} and TypeArmor~\cite{veen:typearmor}. 

TypeArmor, is based on a fine-grained forward edge CFI based policy relying on function parameter count checking during runtime. It calculates invariants for calltargets and indirect 
callsites based on the number of parameters provided at the callsite and consumed at the calltarget  
by leveraging static binary analysis. At the end of the analysis the binary is patched in order to enforce those invariants during runtime. 
While we believe that the general approach to be highly promising, we consider 
as a significant shortcoming that TypeArmor lacks precision with respect to the number of calltargets allowed per callsite which introduces significant 
inefficiencies (see~\cref{{Too Permissive Parameter-Based Policies}} for more details). 
With our work, we aim to achieve both significant precision enhancements and calltarget set per callsite reduction.

In this paper, we present \textsc{TypeShield}, a runtime binary-level fine-grained CFI tool for 
illegitimate forward-edge and backward-edge filtering, 
that significantly reduces the number valid forward and backward targets compared to previous work~\cite{veen:typearmor}. 
\textsc{TypeShield} does not rely on RTTI data (\textit{i.e.,} metadata emitted by the compiler, most of the time stripped) or 
particular compiler flags, and is applicable to industrial software.
\textsc{TypeShield} takes the binary of a program as input and it automatically instruments it in order
to detect illegitimate indirect calls at runtime. In order to achieve this, 
\textsc{TypeShield} analyzes 64-bit binaries by carefully analyzing function parameter counts and related register
characteristics. Based on the used ABI, \textsc{TypeShield} is consequently able to track up to 6 function arguments for the 
Itanium C++ ABI~\cite{itanium:abi} 64-bit calling convention.
However, we stress that the presented methodology is usable for the ARM ABI~\cite{arm:abi} and Microsoft's C++ ABI~\cite{microsoft:abi} as well.
Similarly to TypeArmor, we do not take into consideration floating-point arguments passed via xmm registers; which we want to address in future work. 
As we demonstrate in the evaluation section, this setup provides us with enough information to be significantly more precise than~\cite{veen:typearmor} 
when aiming to stop state-of-the-art CRAs.

%% \textbf{Problem.}
%The performance benefit of late binding comes with high security implications (\textit{i.e.,} arbitrary code executions~\cite{NVD:ACE} reported by NIST NVD, see Figure~\ref{ace:nvd:statistics})
%First, dangling object pointers lead to undefined behavior---as specified by the C++ language standard N4618~\cite{N4618}---which can be exploited to point into illegal (\textit{i.e.,} not previously intended) virtual tables.
%Second, trough memory corruptions (\textit{e.g.,} buffer/integer overflows) the virtual pointer of an object making a call to a virtual function can be corrupted to point into:
%\textit{1)} illegal virtual tables, 
%\textit{2)} newly inserted virtual tables, or
%\textit{3)} overwritten virtual table entries
%such that advanced Code-Reuse Attacks (CRAs) as the advanced COOP~\cite{schuster:coop} attack
%and its extensions~\cite{crane:readactor++, crane:readactor++, subversive-c:lettner, ctf:coop, loop:oriented} 
%become easily doable. This type of attack can bypass most of the to date CFI-based enforcement policies, since:
%\textit{1)} it does not exploit indirect backward edges (\textit{i.e.,} return edges) but rather
%\textit{2)} it exploits the forward indirect control flow transfers imprecision which can not be statically upfront 
%determined since alias analysis is undecidable~\cite{alias:undecidable} in program binaries.
%
%% \textbf{Available Tools.}
%To avoid object dispatch corruptions Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} can be successfully used.
%CFI is one of the most used techniques for securing indirect control flow transfers inside programs
%by usually adding runtime checks before each indirect callsite.
%
%Source code based tools usually insert runtime checks during the compilation of 
%the program such as SafeDispatch~\cite{safedispatch:jang}, ShrinkWrap \cite{haller:shrinkwrap} and IFCC/VTV~\cite{vtv:tice}.
%Other tools modify and reorder the contents of the virtual table layout such as VTI~\cite{bounov:interleaving} 
%in order to derive efficient range checks on each object dispatch during runtime. Nevertheless, to the best of our knowledge 
%due to runtime performance issues only IFCC/VTV~\cite{vtv:tice} is currently in production available.
%
%Binary based tools typically enforce imprecise forward-edge CFI 
%policies, often allowing control transfers from any valid callsite 
%to any valid referenced entry point \textit{e.g.,} binCFI~\cite{ccfir:zhang, zhang:usenix}. 
%In the best case, existing policies only reduce the target set by
%removing all entry points of other modules unless they were
%explicitly exported or observed at runtime~\cite{payer:dimva}. 
%
%TypeArmor~\cite{veen:typearmor} implements a fine grained forward edge CFI 
%policy based on parameter count for binaries. It calculates invariants for calltargets and indirect callsites based on
%the number of parameters they use by leveraging static analysis of the binary, which then is
%patched to enforce those invariants during runtime. 
%The main shortcoming of TypeArmor is that it has low precision 
%w.r.t. to the number of calltargets allowed per callsite 
%(see \cref{{Too Permissive Parameter-Based Policies}} for more details).
%
%VCI~\cite{vci:asiaccs} is a binary rewriting tool that can protect C++ binaries against 
%vtable attacks. VCI strives to reconstruct several language semantics from the binary with limited success.
%These will be later on used for a CFI policy based on resolving pairings of virtual table calls (vcall)
%with precise sets of target classes. The policy is enforced similarly to TypeArmor by inserting the 
%needed checks before each virtual call. VCI performs a restricted type of alias analysis during type propagation.
%Also, it fails in some situations to identify the class types used by a vcall. Additionally, VCI can not deal with 
%virtual-dispatch-like C calls and it fails to find any
%constructor that defines the \textit{this} pointer. Overall, VCI tries to recuperate many high level 
%semantics without focusing on one of them from the binary. As result the calltarget set per callsite is too 
%permissive.
%
%% \textbf{Tool severalLimitations.}
%These source code tools offer a certain degree of protection when code is provided, however 
%the above mentioned binary tools offer limited or no protection due to an in first place
%imprecise calltarget set per callsite.
%
%% \textbf{Our Idea.}
%In this paper, we present \textsc{TypeShield}, a runtime binary-level illegitimate forward calls 
%filtering tool that is based on an improved forward-edge fine-grained CFI policy compared 
%to previous work~\cite{veen:typearmor, crane:readactor++}.
%\textsc{TypeShield} analyzes only 64-bit binaries and only function parameters 
%which are passed with the help of registers. This means that based on the 
%used ABI, \textsc{TypeShield} is able to track 4 or 6 arguments for the Microsoft's x64-bit calling convention
%or System V ABI, respectively. Similarly to TypeArmor we do not take into consideration floating-point 
%arguments passed via xmm registers; which we want to address in future work. However, as we will 
%demonstrate in the evaluation section, this will provide us enough information to 
%more be precisely than TypeArmor when stopping several state-of-the-art CRAs.

\textbf{\textit{Analysis Description.}}~More precisely, the analysis performed by \textsc{TypeShield}:
(1) uses for each function parameter its register wideness (\textit{i.e.,} ABI dependent) in order to map calltargets per callsites,  
(2) uses an address taken (AT) analysis similar to~\cite{veen:typearmor} for all calltargets, and 
(3) compares individually parameters of callsites and calltargets in order to check if an indirect call transfer is acceptable or not, 
thereby providing a more strict calltarget set per callsite compared to other state-of-the-art tools.
\textsc{TypeShield} uses automatically inferred parameter types which are used to build 
a more precise approximation of both the callee parameter types and callsite signatures. 
This is later used during the classification of matching callsites and calltargets, in order to 
distinguish between valid and invalid function calls, and results in a more precise callee target 
set for each caller than other state-of-the-art approaches like, for instance, TypeArmor.

\textbf{\textit{Analysis Details.}}~The \textsc{TypeShield} analysis is based on a use-def callees analysis 
to derive the function prototypes, 
and liveness analysis at indirect callsites to approximate callsite signatures. This 
efficiently leads to a more precise control flow graph (CFG) of the binary program in question, 
which can be used also by other systems in order to gain a more precise CFG on which to 
enforce other types of CFI-related policies. These analysis results are used to
determine a mapping between all callsites and legitimate calltarget sets. Further,
this mapping is used in a backward analysis for determining the set of legitimate 
returns addresses for each function return determined by the each calltarget. Note that 
we consider each calltarget to be the start of function.

\textbf{\textit{Forward Edge Policy.}}~\textsc{TypeShield} incorporates an improved protection policy which is
based on the insight that if the binary adheres to the standard calling convention
for indirect calls, undefined arguments at the callsite are not used by any callee by design. 
This further helps to reduce the possible target set of callees for each callsite.

\textbf{\textit{Backward Edge Policy.}}~~\textsc{TypeShield} uses a forward edge based propagation analysis used to determine a 
set of possible return addresses for function returns which follow the caller calle function calling convention.
The backward-edge policy is available in three modes: 
(1) super fast mode, a range is imposed for each AT function return formed by the minimum and maximum legitimate addresses,
(2) fast mode, each AT function return contains a label value which is compared against several return targets labels, and
(3) slow mode, each AT function return address is compared individually with each legitimate return address target where the calltarget (\textit{i.e.,} function return) wants to return to.
This backward-edge policy modes represent effective fine-grained SafeStack~\cite{volodymyr:cpi} (\textit{i.e.,} compiler based protection recently bypassed~\cite{safestack:bypassing}.) alternatives. 

\textbf{\textit{Comparison.}}~\textsc{TypeShield} uses different basic block analysis strategies than TypeArmor,
and no control flow graph as TypeArmor does. Further,~\textsc{TypeShield}
disallows a forward indirect call transfer where the types of the arguments provided are not super 
types (\textit{i.e.,} the float type is a super type for int) of the arguments expected at the target. Also, it disallows backward edge indirect control flow transfers which do not 
point to addresses located after a callsite which is allowed to call the function (calltarget) containing the function 
return (backward edge starting point).
Further, similar to TypeArmor, \textsc{TypeShield} disallows forward indirect control flow transfers that 
prepares fewer arguments than the target callee consumes since otherwise it would risk breaking the binary.
This invariants are used to enforce that each callsite targets only a strict calltarget set.
Finally, the program binary hardened by \textsc{TypeShield} contains a considerably reduced available calltarget set per callsite 
and return set per function return site, thus drastically reducing the attacker leeway.

% \textbf{Contributions.} 
In summary, we make the following contributions:
%%long version
% \label{Contribution}
% \begin{itemize}[leftmargin=.12in]
% 
%  \item \textbf{Novel Forward-Backward Edge Protection Technique.} We designed a novel illegitimate indirect calls detection technique based on function parameter 
%  count and types which is considerably more precise w.r.t. to the enforced legitimate calltarget set per callsite than other state-of-the-art techniques.
%  
%  \item \textbf{Implemented and Usable Prototype.} We implemented, \textsc{TypeShield}, a prototype which enforces the aforementioned technique.
%  \textsc{TypeShield} is a general, automated, and easy-to-deploy 
%  tool that can be applied to C/C++ binaries in order to detect and mitigate illegitimate forward indirect calls  during runtime. 
%  Further, \textsc{TypeShield} has an expanded scope of analysis. \textsc{TypeShield} can detect forbidden indirect calls and as such it can protect, 
%  similarly as vTrust~\cite{zhang:vtrust}, against virtual table injection, corruption and reuse attacks. Further it can protect also against the 
%  control flow jujutsu attack~\cite{jujutsu} since our policy checks for void and non-void functions. 
%  As such \textsc{TypeShield} can serve as a platform for developing other types of defenses for different types of attacks. 
%  
%  \item \textbf{Security Analysis.} We provide a thorough security analysis of forward indirect calls. We analyze the usage of illegitimate indirect forward calls in detail, 
%  thus providing security researchers and practitioners a better understanding of this emerging threat 
%  (see~\cref{C++ Indirect Calls in Practice},~\cref{Security Implications of Forbidden Forward Indirect Calls},~\cref{Real COOP Attack Example}, and ~\cref{Too Permissive Parameter-Based Policies}
%  for more details).
%  
%  \item \textbf{Evaluation.} We conduct a thorough set of evaluative experiments. In particular, we demonstrate experimentally that our precise binary-level 
%  CFI technique can mitigate advanced code reuse attacks (CRAs) in absence of C++ semantics. For example, \textsc{TypeShield} can effectively protect against 
%  the COOP attack and its variations. Thereby, it achieves a high degree of precision. Specifically, it 
%  employs a more precise analysis than TypeArmor in order to reduce the calltarget set for each callsite. 
%  
%  \item \textbf{Detailed Comparison} Our evaluation shows that \textsc{TypeShield} imposes up to 4\% overhead for performance-intensive benchmarks such as the SPEC CPU2006 benchmarks
%  which is comparable to TypeArmors runtime overhead ($\approx$ 3\%) on the same programs.
%  Our evaluation shows that it gains between 13\% and 35\% more precision with respect to TypeArmor on the same programs. Further, we showcase similar {performance} enhancements in 
%  comparison to prior work. \textsc{TypeShield} employs runtime policy optimization techniques to further reduce runtime overheads. This is necessary, since our 
%  runtime checks are more complex than those used by TypeArmor.
%  
%  \item \textbf{Reproducibility of Results.} The source code, test scripts and 
%  evaluation results of \textsc{TypeShield} will be available at \url{https://github.com/domain/typeshield} upon paper acceptance.
%  We respond to calls emphasizing the importance of reproducibility of evaluation results (see NISTIR 7564~\cite{reprod:nist}) by 
%  providing for each conducted experiment a precise description of the experiment setup, and comprehensive results, including mean, median, geomean, standard deviation values
%  and encountered issues.
%  
% \end{itemize}

%short version
\label{Contribution}
\begin{itemize}
% [leftmargin=.35cm]

 \item \textbf{Novel CFI-based protection technique.} We designed a novel fine-grained CFI technique for protecting forward and backward edges in a CFG
 against code reuse attacks.
 
 \item \textbf{Implemented an usable prototype.} We implemented, \textsc{TypeShield}, a prototype which enforces the aforementioned technique
 in stripped program binaries. \textsc{TypeShield} can serve as platform for developing other binary based protection mechanisms.
 
 \item \textbf{Evaluation.} We conduct a thorough set of evaluative experiments in which we show that \textsc{TypeShield} is more precise and effective than 
 other state-f-the-art tools. Further, we show that our tool has a higher calltarget set reduction per callsite, thus further reducing the attack surface.
 
 \item \textbf{Reproducibility of results.} 
 We respond to calls emphasizing the importance of reproducibility of evaluation results (see NISTIR 7564~\cite{reprod:nist} and the security and measurements 
 section in~\cite{herley:security}) by releasing \textsc{TypeShield} open source and by providing for each conducted experiment a precise description.
 
\end{itemize}


% 
% \newsavebox{\firstlisting}
% \begin{lrbox}{\firstlisting}
% \begin{minipage}[c]{\linewidth}
% \begin{minted}[
% % frame=lines,
% framesep=2mm,
% linenos,
% frame=none,
% firstnumber=1,
% framesep = 1.0cm,
% linenos,
% numbersep=5pt,
% %gobble=2,
% %frame=lines,
% framesep=2mm,
% %fontsize=\tiny        
% % baselinestretch=1.2,
% % bgcolor=LightGray,
% fontsize=\small,
% ]{C++}
% class nsMultiplexInputStream final 
%  :public nsIMultiplexInputStream //A0
%  ,public nsISeekableStream //A1
%  ,public nsIIPCSerializableInputStream //A2
%  ,public nsICloneableInputStream{ //A3
% nsTArray<nsCOMPtr<nsIInputStream>> mStreams;
% NS_IMETHODIMP nsMultiplexInputStream::Close(){
%   MutexAutoLock lock(mLock);
%   mStatus = NS_BASE_STREAM_CLOSED;
%   //set NS_OK flag
%   nsresult rv = NS_OK;
%   //get array length
%   uint32_t len = mStreams.Length();
%   //array-based main loop gadget (ML-G)
%  for (uint32_t i = 0; i<len; ++i){
%   //(1) hijacked indirect call
%   nsresult rv2=mStreams[i]->Close();
%   if (NS_FAILED(rv2)) {
%       rv = rv2;
%   }
%  }
%   return rv;
% }
% \end{minted}
% \end{minipage}
% \end{lrbox}

% \begin{figure}
%  \begin{minipage}[!t]{.40\linewidth}
%   \usebox{\firstlisting}
%  \end{minipage}%%
% \hfill
% \hspace{1.2cm}
% \begin{minipage}[!b]{.5\linewidth}
%    \includegraphics[width=1.3\textwidth]{figures/loop.pdf}
% \end{minipage}
% \caption{Code example used to illustrate how a COOP loop gadget works.}
% \label{Code example used to illustrate how a COOP loop gadget works}
% \end{figure}

%%%%%%%%%%%%%%%%%
%  \begin{figure*}[!t]
%     \centering
%    \setlength{\unitlength}{0.1\textwidth}
%    \begin{picture}(10,4)
% %    \centering
%      \put(4.81,0){\includegraphics[width=.43\textwidth]{figures/loop.pdf}}
%      \put(1.5,2){\usebox{\firstlisting}}
%    \end{picture}
% \caption{Description of how a counterfeit object-oriented programming main loop gadget (ML-G) works.}
% \label{Code example used to illustrate how a COOP loop gadget works}
% \end{figure*}

%most probably not needed at this time.
% \label{Outline}
% \textbf{Outline.} 
% The remainder of this paper is organized as follows.
% \cref{C++ Bad Forward Indirect Calls} explains forbidden forward indirect calls issues and their security implications, and 
% \cref{chapter:TypeShild Overview} contains an overview of \textsc{TypeShield}.
% \cref{chapter:Design} describes the theory used and decisions made during the design of \textsc{TypeShield}, and
% \cref{chapter:Implementation} briefly presents the implementation details of \textsc{TypeShield}, while
% \cref{chapter:Evaluation} evaluates several properties of \textsc{TypeShield}.
% \cref{chapter:Discussion} contains the discussion, and
% \cref{chapter:Related_Work} surveys related work, while
% \cref{chapter:Future_Work} highlights future research venues. 
% Finally,~\cref{chapter:Conclusion} concludes this paper.


