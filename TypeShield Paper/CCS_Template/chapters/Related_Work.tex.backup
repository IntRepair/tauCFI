\section{Related Work}
\label{chapter:Related_Work}

\subsection{Type-Inference on Executables}
\label{Type-Inference on Executables}
Recovering variable types from executable programs
is very hard in general for several reasons. 
First, the quality of the disassembly can very much from used
framework to another. \textsc{TypeShield} is based on DynInst 
and the quality of the executable disassembly fits our needs. 
For a more comprehensive review on the capabilities of DynInst and other tools we
advice the reader to have a look at~\cite{andriesse:indepth}.
Second, alias analysis in binaries is undecidable in theory and intractable in practice~\cite{alan:mycroft}.
There are several most promising tools such as: Rewards~\cite{lin:rewards}, BAP~\cite{bap:brumley}, 
SmartDec~\cite{fokin:smartdec}, and Divine~\cite{divine:balakrishnan}.
These tools try with more or less success to recover 
type information from binary programs with different goals.
Typical goals are: 
\textit{i)} full program reconstruction (\textit{i.e.,} binary to code conversion, reversing, etc.), 
\textit{ii)} checking for buffer overflows, 
\textit{iii)} integer overflows and other types of memory corruptions.
For a more exhaustive review of such tools we advice the reader to
have a look at the review of Caballero \textit{et al.}~\cite{caballero:inference}.
Interesting to notice is that the code from only a few of these tools is actually available.

While SmartDec seemed promising due to its simple type lattice that we wanted to leverage for our classification schema. 
Its integration into our DynInst based environment was not successful mostly for time constraints, as it was deemed to 
time consuming to extract the whole machinery and implement an interface to the DynInst disassembler.
Therefore, we finally implemented our own version of type analysis and only focused on the wideness of the types, 
resulting in a simpler lattice than we initially wanted.

% %maybe not relevant
\subsection{Mitigation of not Advanced CRAs}
\label{Mitigation of Code-Reuse Attacks}
In the last couple of years researchers have provided many versions of new Code Reuse Attacks (CRAs).
These new attacks were possible since DEP~\cite{dep} and ASLR~\cite{ASLR} were successfully bypassed mostly based
on Return Oriented Programming (ROP)~\cite{ROP, kornau:rop, rop:shacham} on one hand and due to the discovery of 
new exploitable hardware and software primitives, on the other hand.

ROP started to present itself in the last couple of years in many faceted ways such as:
Jump Oriented Programming (JOP)~\cite{JOP1, JOP2, JOP3} which uses jumps in order to divert the control flow to the next gadget and 
Call Oriented Programming (COP)~\cite{rop:carlini} which uses calls in order to chain gadgets together.
CRAs have many manifestations and it is out of scope of this work to list them all.

First, CRAs can be mitigated in general in the following ways: 
\textit{i)} binary instrumentation,
\textit{ii)} source code recompilation and 
\textit{iii)} runtime application monitoring.
Second, there is a plethora of tools and techniques which try to enforce CFI based
primitives in executables, source code and during runtime. Thus, we briefly
present the solution landscape together with the approaches and the techniques on which these are based:
\textit{a)} fine-grained CFI with hardware support, PathArmor~\cite{veen:cfi},
\textit{b)} coarse-grained CFI used for binary instrumentation, CCFIR~\cite{ccfir:zhang},
\textit{c)} coarse-grained CFI based on binary loader, CFCI~\cite{cfci:zhang}
\textit{d)} fine-grained code randomization, O-CFI~\cite{mohan:opaque},
\textit{e)} cryptography with hardware support, CCFI~\cite{ccfi:jose},
\textit{f)} ROP stack pivoting, PBlocker~\cite{pblocker:prakash},
\textit{g)} canary based protection, DynaGuard~\cite{dynaguard:petsios},
\textit{h)} runtime and hardware support based on a combination of LBR, PMU and BTS registers CFIGuard~\cite{cfiguard:yuan}, and
\textit{i)} source code recompilation with CFI and/or randomization enforcement against JIT-ROP attacks, MCFI~\cite{mcfi:niu}, 
RockJIT~\cite{rockjit:niu} and PiCFI~\cite{perinput:niu}.

The above list is not exhaustive and new protection techniques can be obtained by combining available techniques
or by using newly available hardware features or software exploits. However, notice that none of the above mentioned 
techniques and tools can be used to mitigate COOP attacks.

\subsection{Mitigation of Advanced CRAs}
\textbf{Mitigation of Forward-Edge based Attacks.}
\label{Mitigation of Advanced Code-Reuse Attacks}
Recursive-COOP~\cite{crane:readactor++}, COOP~\cite{schuster:coop}, Subversive-C~\cite{subversive-c:lettner} and the attack of Lan \textit{et al.}~\cite{loop:oriented} are 
forward-edge based CRAs which cannot be addressed with:
\textit{i)}  shadow stacks techniques and hardware-based approaches such as Intel CET~\cite{intel:cet} (\textit{i.e.,} since advanced COOP do not violate 
the caller/callee convention), 
\textit{ii)} coarse-grained Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} techniques, and 
\textit{iii)} OS-based approaches such as Windows Control Flow Guard~\cite{windows:cfguard} 
since the precomputed CFG does not contain edges for indirect callsites which are explicitly exploited during the COOP attack.

\subsubsection{Binary Based Techniques}
The following tools address vTable protection through binary instrumentation, 
but fail to mitigate against COOP: vfGuard~\cite{vfuard:aravind}, and vTint~\cite{vtint:zhang}. 
The only binary-based tool which we are aware of that can protect against COOP is TypeArmor~\cite{veen:typearmor}. 
TypeArmor uses a fine-grained CFI policy based on caller/callee (but only indirect callsites) matching, which checks 
during runtime if the number of provided and needed parameters match.

\textsc{TypeShield} is related to TypeArmor~\cite{veen:typearmor}, since we also enforce strong binary-level 
invariants on the number of function parameters. Further, \textsc{TypeShield} also aims for exclusive protection 
against advanced exploitation techniques, which can bypass fine-grained CFI schemes and vTable protections at the 
binary level. However, \textsc{TypeShield} offers a better restriction of calltargets to callsites, since we not 
only restrict based on the number of parameters, but also on the width of their types. This results in much smaller 
buckets that in turn can only target a smaller subset of all address-taken functions. 
%However, we rely for that on the variety of parameter types and when there is none, we will degrade into a parameter count policy.

We are aware that there is still a long research path to go until binary based techniques can 
recuperate program based semantic information from executable with the same precision as compiler based tools.
This path could be even endless since compilers are optimized for speed and are designed to remove as much as possible semantic information
from an executable in order to make the program run as fast as possible. In light of this fact,
\textsc{TypeShield} is another attempt to recuperate just the needed semantic information (types and number of function parameters from
indirect callsites) in order to be able to enforce a precise and with low overhead primitive against COOP attacks.

In this paper, rather than claiming that the invariants offered by~\textsc{TypeShield} are sufficient
to mitigate all versions of the COOP (as \cite{veen:typearmor} does) attack we conservatively claim that~\textsc{TypeShield} 
further raises the bar w.r.t. what is possible when defending against COOP attacks on the binary level.

\subsubsection{Source Code Based Techniques} Indirect callsite targets are checked based on vTable integrity.
Different types of CFI policies are used such as in the following tools:
SafeDispatch~\cite{safedispatch:jang}, IFCC/VTV~\cite{vtv:tice} LLVM and GCC compiler.
Additionally, the Redactor++~\cite{crane:readactor++} uses randomization 
vTrust~\cite{zhang:vtrust} checks calltarget function signatures, 
CPI~\cite{volodymyr:cpi} uses a memory safety technique
in order to protect against the COOP attack.

There are several source code based tools 
which can successfully protect against the COOP attack.
Such tools are: ShrinkWrap~\cite{haller:shrinkwrap}, IFCC/VTV~\cite{vtv:tice}, 
SafeDispatch~\cite{safedispatch:jang}, vTrust~\cite{zhang:vtrust}, Readactor++~\cite{crane:readactor++}, CPI~\cite{volodymyr:cpi} and the
tool presented by Bounov \textit{et al.}~\cite{bounov:interleaving}. These tools profit from high precision
since they have access to the full semantic context of the program though the scope
of the compiler on which they are based. 
Because of this reason, these tools target mostly other types of security problems than binary-based 
tools address. For example, some of the last advancements in compiler based protection against code reuse attacks address mainly performance issues.
Currently, most of the above presented tools are only forward edge enforcers of fine-grained CFI policies with an overhead from 1\% up to 15\%.

\subsubsection{Runtime Based Techniques}
Several promising runtime-based defenses against advanced CRAs exist but currently none of them can successfully
protect against the COOP attack.

IntelCET~\cite{intel:cet} is based on, \texttt{ENDBRANCH}, a new CPU instruction which can be used to enforce
an efficient shadow stack mechanism. The shadow stack can be used to check during program execution if caller/return pairs match.
Since the COOP attack reuses whole functions as gadgets and does not violate the caller/return convention than the 
new feature provided by intel is useless in the face of this attack. Nevertheless, other highly notorious CRAs may not be possible
after this feature will be implemented main stream in OSs and compilers.

Windows Control Flow Guard~\cite{windows:cfguard} is based on a user-space and kernel-space components which
by working closely together can enforce an efficient fine-grained CFI policy based on a precomputed CFG.
These new feature available in Windows 10 can considerably rise the bar for future attacks but in our opinion advanced CRAs
such as COOP are still possible due the typical characteristics of COOP.

PathArmor~\cite{veen:cfi} is yet another tool which is based on a precomputed CFG and on the LBR register which can give a string of 16 up to
32 pairs of from/to addressed of different types of indirect instructions such as \texttt{call}, \texttt{ret}, and \texttt{jump}. 
Because of the sporadic query of the LBR register (only during invocation of certain function calls) and because of the sheer amount of 
data which passes through the LBR register this approach has in our opinion a fair potential to catch different types of CRAs but
we think that against COOP this tool can be used only with limited success. 
First, because of the fact that the precomputed CFG does not contain edges for all
possible indirect callsites which are accessed during runtime. Second, the LBR buffer can be easily fooled by interleaving
legitimate with illegitimate indirect callsites during the COOP attack.


