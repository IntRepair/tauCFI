\section{Overview}
\label{chapter:TypeShild Overview}
% In this section, we present a brief overview on the 
% considered adversary model in~\cref{Adversary Model} and depict the 
% invariants for calltargets and callsites in~\cref{Invariants for Targets and Callsites}.
% Finally, in~\cref{TypeShield Policy Mechanism} we present our function parameter type aware policy and give a formal description of it
% by relating it to~\cite{veen:typearmor}, and in~\cref{TypeShild Impact on COOP} we highlight the impact of our policy on COOP.

% \textbf{Adversary Model and Assumptions.}
\subsection{Adversary Model and Assumptions}
\label{Adversary Model}

We largely use the same threat model and the same basic assumptions as described in the TypeArmor 
paper~\cite{veen:typearmor}, meaning that our attacker has read and write access to the data 
sections of the attacked binary.  We also assume that the protected binary does not contain 
self-modifying code, handcrafted assembly or any kind of obfuscation. We also consider pages 
to be either writable or executable but not both at the same time. We assume 
that our attacker has the ability to execute a memory corruption to hijack the program
control flow and that a solution for backward CFI is in place.

\subsection{\textsc{TypeShield} Policy Mechanism}
\label{TypeShield Policy Mechanism}

\begin{figure}[H]
% \captionsetup{labelformat=empty}
\vspace{-.5cm}
\hspace{-.3cm}
\resizebox{0.49\textwidth}{!}{
\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
    \begin{scope}
            % labels
%     \foreach \i in {0,...,5}
%       \path[blue] (0,-0.25) node{0} (-0.25,0) node{0};
      \path[blue] (0.25,-0.25) node{1}  (-0.25, 0.25) node{0};
      \path[blue] (0.75,-0.25) node{2}  (-0.25, 0.75) node{1};
      \path[blue] (1.25,-0.25) node{3}  (-0.25, 1.25) node{2};
      \path[blue] (1.75,-0.25) node{4}  (-0.25, 1.75) node{4};
      \path[blue] (2.25,-0.25) node{5}  (-0.25, 2.25) node{8};
      \path[blue] (2.75,-0.25) node{6} (-0.25, 2.75) node{};
%       \path[blue] (7/2,-0.25) node{64} (-0.25,7/2) node{64};
    % loop over the lattice points
    \foreach \i in {0,...,6}
      \foreach \j in {0,...,6}{
       \ifnum \j < 6
        \draw (\i / 2,\j / 2) rectangle (1,1);
        \fi
        % check if (\i,\j) > (2,2)
%         \ifnum \i < 3
%           \ifnum \j < 3
%             \fill[red] (\i + 0.25,\j + 0.25) circle(3pt);
%           \fi
%         \fi
      };
      
      \fill (0   + 0.25, 0   + 0.25) circle(4pt);
      \fill (0.5 + 0.25, 0.5 + 0.25) circle(4pt);
      \fill (0 + 0.25, 0.5 + 0.25) circle(4pt);
      \fill (0.5 + 0.25, 0 + 0.25) circle(4pt);
      \fill (0.5 + 0.25, 1 + 0.25) circle(4pt);
      \fill (0 + 0.25, 1 + 0.25) circle(4pt);
      %       \draw [line width=0.5mm, green] (1 + 0.25, 1 + 0.25) circle (6pt);
      
%       \draw (0.5 + 0.25, 3 + 0.25) circle(4pt);
%       \draw (0 + 0.25, 3 + 0.25) circle(4pt);
%       \draw (1 + 0.25, 3 + 0.25) circle(4pt);
%       \draw (1 + 0.75, 3 + 0.25) circle(4pt);
%       \draw (2.25, 3 + 0.25) circle(4pt);
%       \draw (2.75, 3 + 0.25) circle(4pt);
%       \draw (3.25, 3 + 0.25) circle(4pt);
      
%       \draw (0.5 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw (0 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw (1 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw (1 + 0.75, 2.5 + 0.25) circle(4pt);
%       \draw (2.25, 2.5 + 0.25) circle(4pt);
%       \draw (2.75, 2.5 + 0.25) circle(4pt);
%       \draw (3.25, 2.5 + 0.25) circle(4pt);
      
      \draw (0.5 + 0.25, 2 + 0.25) circle(4pt);
      \draw (0 + 0.25, 2 + 0.25) circle(4pt);
      \draw (1 + 0.25, 2 + 0.25) circle(4pt);
      \draw (1 + 0.75, 2 + 0.25) circle(4pt);
      \draw (2.25, 2 + 0.25) circle(4pt);
      \draw (2.75, 2 + 0.25) circle(4pt);
%       \draw (3.25, 2 + 0.25) circle(4pt);
      
      \fill (0.5 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (0 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (1 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (1 + 0.75, 1.5 + 0.25) circle(4pt);
      \draw (2.25, 1.5 + 0.25) circle(4pt);
      \draw (2.75, 1.5 + 0.25) circle(4pt);
%       \draw (3.25, 1.5 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 1 + 0.25) circle(4pt);
      \fill (1 + 0.75, 1 + 0.25) circle(4pt);
      \fill (2.25, 1 + 0.25) circle(4pt);
      \fill (2.75, 1 + 0.25) circle(4pt);
%       \draw (3.25, 1 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 0.5 + 0.25) circle(4pt);
      \fill (1 + 0.75, 0.5 + 0.25) circle(4pt);
      \fill (2.25, 0.5 + 0.25) circle(4pt);
      \fill (2.75, 0.5 + 0.25) circle(4pt);
%       \fill (3.25, 0.5 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 0 + 0.25) circle(4pt);
      \fill (1 + 0.75, 0 + 0.25) circle(4pt);
      \fill (2.25, 0 + 0.25) circle(4pt);
      \fill (2.75, 0 + 0.25) circle(4pt);
%       \fill (3.25, 0 + 0.25) circle(4pt);
    \end{scope}
    
    \begin{scope}[xshift=1.5cm, yshift=2.75cm]
     \node[]    (q_1) {	\large{$M1:call \ site$}};
    \end{scope}
    
    \begin{scope}[xshift=3.25cm, yshift=1.2cm]
     \node[]    (q_1) {	\large{$\wedge$}};
    \end{scope}
    
    \begin{scope}[xshift=5.3cm, yshift=2.75cm]
     \node[]    (q_1) {	\large{$M2:call \ target$}};
    \end{scope}
    
    \begin{scope}[xshift=9cm, yshift=2.75cm]
     \node[]    (q_1) {\large{$M3:policy \ result$}};
    \end{scope}

    \begin{scope}[xshift=3.8cm]
       % labels
%     \foreach \i in {0,...,5}
%       \path[blue] (0,-0.25) node{0} (-0.25,0) node{0};
      \path[blue] (0.25,-0.25) node{1}  (-0.25, 0.25) node{0};
      \path[blue] (0.75,-0.25) node{2}  (-0.25, 0.75) node{1};
      \path[blue] (1.25,-0.25) node{3}  (-0.25, 1.25) node{2};
      \path[blue] (1.75,-0.25) node{4}  (-0.25, 1.75) node{4};
      \path[blue] (2.25,-0.25) node{5}  (-0.25, 2.25) node{8};
      \path[blue] (2.75,-0.25) node{6} (-0.25, 2.75) node{};
%       \path[blue] (7/2,-0.25) node{64} (-0.25,7/2) node{64};
    % loop over the lattice points
    \foreach \i in {0,...,6}
      \foreach \j in {0,...,6}{
      \ifnum \j < 6
       \draw (\i / 2,\j / 2) rectangle (1,1);
      \fi
        
        % check if (\i,\j) > (2,2)
%         \ifnum \i < 3
%           \ifnum \j < 3
%             \fill[red] (\i + 0.25,\j + 0.25) circle(3pt);
%           \fi
%         \fi
      };
      
      \draw (0   + 0.25, 0   + 0.25) circle(4pt);
      \draw (0.5 + 0.25, 0.5 + 0.25) circle(4pt);
      \draw (0 + 0.25, 0.5 + 0.25) circle(4pt);
      \draw (0.5 + 0.25, 0 + 0.25) circle(4pt);
      \draw (0.5 + 0.25, 1 + 0.25) circle(4pt);
      \draw (0 + 0.25, 1 + 0.25) circle(4pt);
      
%       \fill (0.5 + 0.25, 3 + 0.25) circle(4pt);
%       \fill (0 + 0.25, 3 + 0.25) circle(4pt);
%       \fill (1 + 0.25, 3 + 0.25) circle(4pt);
%       \fill (1 + 0.75, 3 + 0.25) circle(4pt);
%       \fill (2.25, 3 + 0.25) circle(4pt);
%       \fill (2.75, 3 + 0.25) circle(4pt);
%       \fill (3.25, 3 + 0.25) circle(4pt);
      
%       \fill (0.5 + 0.25, 2.5 + 0.25) circle(4pt);
%       \fill (0 + 0.25, 2.5 + 0.25) circle(4pt);
%       \fill (1 + 0.25, 2.5 + 0.25) circle(4pt);
%       \fill (1 + 0.75, 2.5 + 0.25) circle(4pt);
%       \fill (2.25, 2.5 + 0.25) circle(4pt);
%       \fill (2.75, 2.5 + 0.25) circle(4pt);
%       \fill (3.25, 2.5 + 0.25) circle(4pt);
      
      \fill (0.5 + 0.25, 2 + 0.25) circle(4pt);
      \fill (0 + 0.25, 2 + 0.25) circle(4pt);
      \fill (1 + 0.25, 2 + 0.25) circle(4pt);
      \fill (1 + 0.75, 2 + 0.25) circle(4pt);
      \fill (2.25, 2 + 0.25) circle(4pt);
      \fill (2.75, 2 + 0.25) circle(4pt);
%       \fill (3.25, 2 + 0.25) circle(4pt);
      
      \fill (0.5 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (0 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (1 + 0.25, 1.5 + 0.25) circle(4pt);
      \fill (1 + 0.75, 1.5 + 0.25) circle(4pt);
      \fill (2.25, 1.5 + 0.25) circle(4pt);
      \fill (2.75, 1.5 + 0.25) circle(4pt);
%       \fill (3.25, 1.5 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 1 + 0.25) circle(4pt);
      \fill (1 + 0.75, 1 + 0.25) circle(4pt);
      \fill (2.25, 1 + 0.25) circle(4pt);
      \fill (2.75, 1 + 0.25) circle(4pt);
%       \fill (3.25, 1 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 0.5 + 0.25) circle(4pt);
      \fill (1 + 0.75, 0.5 + 0.25) circle(4pt);
      \fill (2.25, 0.5 + 0.25) circle(4pt);
      \fill (2.75, 0.5 + 0.25) circle(4pt);
%       \fill (3.25, 0.5 + 0.25) circle(4pt);
      
      \fill (1 + 0.25, 0 + 0.25) circle(4pt);
      \fill (1 + 0.75, 0 + 0.25) circle(4pt);
      \fill (2.25, 0 + 0.25) circle(4pt);
      \fill (2.75, 0 + 0.25) circle(4pt);
%       \fill (3.25, 0 + 0.25) circle(4pt);
      requires
    \end{scope}
    
    \begin{scope}[xshift=7cm, yshift=1.2cm]
     \node[]    (q_1) {\Large{$=$}};
    \end{scope}
    
     \begin{scope}[xshift=7.5cm]
            % labels
%     \foreach \i in {0,...,5}
%       \path[blue] (0,-0.25) node{0} (-0.25,0) node{0};
      \path[blue] (0.25,-0.25) node{1}  (-0.25, 0.25) node{0};
      \path[blue] (0.75,-0.25) node{2}  (-0.25, 0.75) node{1};
      \path[blue] (1.25,-0.25) node{3}  (-0.25, 1.25) node{2};
      \path[blue] (1.75,-0.25) node{4}  (-0.25, 1.75) node{4};
      \path[blue] (2.25,-0.25) node{5}  (-0.25, 2.25) node{8};
      \path[blue] (2.75,-0.25) node{6} (-0.25, 2.75) node{};
%       \path[blue] (7/2,-0.25) node{64} (-0.25,7/2) node{64};
    % loop over the lattice points
    \foreach \i in {0,...,6}
      \foreach \j in {0,...,6}{
      \ifnum \j < 6
       \draw (\i / 2,\j / 2) rectangle (1,1);
      \fi
        
        % check if (\i,\j) > (2,2)
%         \ifnum \i < 3
%           \ifnum \j < 3
%             \fill[red] (\i + 0.25,\j + 0.25) circle(3pt);
%           \fi
%         \fi
      };
      
      \fill (0   + 0.25, 0   + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0   + 0.25, 0   + 0.25) circle (6pt);
      \fill (0.5 + 0.25, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0.5 + 0.25, 0.5 + 0.25) circle (6pt);
      \fill (0 + 0.25, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0 + 0.25, 0.5 + 0.25) circle (6pt);
      \fill (0.5 + 0.25, 0 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0.5 + 0.25, 0 + 0.25) circle (6pt);
      \fill (0.5 + 0.25, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0.5 + 0.25, 1 + 0.25) circle (6pt);
      \fill (0 + 0.25, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0 + 0.25, 1 + 0.25) circle (6pt);
      
%       \draw (0.5 + 0.25, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (0.5 + 0.25, 3 + 0.25) circle (6pt);
%       \draw (0 + 0.25, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (0 + 0.25, 3 + 0.25) circle (6pt);
%       \draw (1 + 0.25, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (1 + 0.25, 3 + 0.25) circle (6pt);
%       \draw (1 + 0.75, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (1 + 0.75, 3 + 0.25) circle (6pt);
%       \draw (2.25, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (2.25, 3 + 0.25) circle (6pt);
%       \draw (2.75, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (2.75, 3 + 0.25) circle (6pt);
%       \draw (3.25, 3 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 3 + 0.25) circle (6pt);
      
%       \draw (0.5 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (0.5 + 0.25, 2.5 + 0.25) circle (6pt);
%       \draw (0 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (0 + 0.25, 2.5 + 0.25) circle (6pt);
%       \draw (1 + 0.25, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (1 + 0.25, 2.5 + 0.25) circle (6pt);
%       \draw (1 + 0.75, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (1 + 0.75, 2.5 + 0.25) circle (6pt);
%       \draw (2.25, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (2.25, 2.5 + 0.25) circle (6pt);
%       \draw (2.75, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (2.75, 2.5 + 0.25) circle (6pt);
%       \draw (3.25, 2.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 2.5 + 0.25) circle (6pt);
      
      \draw (0.5 + 0.25, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0.5 + 0.25, 2 + 0.25) circle (6pt);
      \draw (0 + 0.25, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (0 + 0.25, 2 + 0.25) circle (6pt);
      \draw (1 + 0.25, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (1 + 0.25, 2 + 0.25) circle (6pt);
      \draw (1 + 0.75, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (1 + 0.75, 2 + 0.25) circle (6pt);
      \draw (2.25, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (2.25, 2 + 0.25) circle (6pt);
      \draw (2.75, 2 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (2.75, 2 + 0.25) circle (6pt);
%       \draw (3.25, 2 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 2 + 0.25) circle (6pt);
      
      \fill (0.5 + 0.25, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (0.5 + 0.25, 1.5 + 0.25) circle (6pt);
      \fill (0 + 0.25, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (0 + 0.25, 1.5 + 0.25) circle (6pt);
      \fill (1 + 0.25, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.25, 1.5 + 0.25) circle (6pt);
      \fill (1 + 0.75, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.75, 1.5 + 0.25) circle (6pt);
      \draw (2.25, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (2.25, 1.5 + 0.25) circle (6pt);
      \draw (2.75, 1.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, red] (2.75, 1.5 + 0.25) circle (6pt);
%       \draw (3.25, 1.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 1.5 + 0.25) circle (6pt);
      
      \fill (1 + 0.25, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.25, 1 + 0.25) circle (6pt);
      \fill (1 + 0.75, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.75, 1 + 0.25) circle (6pt);
      
      \fill (2.25, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.25, 1 + 0.25) circle (6pt);
      \fill (2.75, 1 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.75, 1 + 0.25) circle (6pt);
%       \draw (3.25, 1 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 1 + 0.25) circle (6pt);
      
      \fill (1 + 0.25, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.25, 0.5 + 0.25) circle (6pt);
      \fill (1 + 0.75, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.75, 0.5 + 0.25) circle (6pt);
      \fill (2.25, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.25, 0.5 + 0.25) circle (6pt);
      \fill (2.75, 0.5 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.75, 0.5 + 0.25) circle (6pt);
%       \draw (3.25, 0.5 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 0.5 + 0.25) circle (6pt);
      
      \fill (1 + 0.25, 0 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.25, 0 + 0.25) circle (6pt);
      \fill (1 + 0.75, 0 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (1 + 0.75, 0 + 0.25) circle (6pt);
      \fill (2.25, 0 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.25, 0 + 0.25) circle (6pt);
      \fill (2.75, 0 + 0.25) circle(4pt);
      \draw [line width=0.5mm, green] (2.75, 0 + 0.25) circle (6pt);
%       \draw (3.25, 0 + 0.25) circle(4pt);
%       \draw [line width=0.5mm, red] (3.25, 0 + 0.25) circle (6pt);
    \end{scope}
    
\end{tikzpicture}}
\caption{\textsc{TypeShield}'s parameter type and count policy. 
The $X$ and $Y$ axis of matrices $M1, M2$ and $M3$ represent function parameter count 
and bit-widths in bytes, respectively.
Note that our type policy performs an $\wedge$ (\textit{i.e.,} logical and) operation
between each entry in $M1_{i,j}$ and $M2_{i,j}$ where $i$ and $j$ are column and row indexes. 
If two black filled circles located in $M1$ $\wedge$ $M2$ overlap on positions $M1_{i} = M2_{i} \wedge M1_{j} = M2_{j}$ than we have a match.
Green circles indicate a match whereas red circles indicate a mismatch in $M3$.
If at least one match is present on each of the columns of 
$M3$ than the indirect call transfer will be allowed by our policy, 
otherwise not. Note that in this example
the indirect call transfer will be allowed.}
\label{Type and parameter count policy.}
\end{figure}

Figure~\ref{Type and parameter count policy.} depicts the behavior of our type based policy
when the callsite provides 6 parameters $pcs1, ..., pcs6$ having following bit 
wideness \textit{pcs}1: 4-byte, \textit{pcs}2: 4-bye, \textit{pcs}3: 4-byte, \textit{pcs}4: 8-byte, \textit{pcs}5: 2-byte, 
\textit{pcs}6: 2-byte, and the calltarget is expecting 6 parameters $pct1, ..., pct6$ having following bit 
wideness \textit{pct}1: 4-byte, \textit{pct}2: 4-bye, \textit{pct}3: 0-byte, \textit{pct}4: 0-byte, \textit{pct}5: 0-byte, 
\textit{pct}6: 0-byte of the expected parameters. 
\textsc{TypeShield}'s type policy is defined as follows. 
\label{eqn:1}{
\textit{Definition 3.1} Let $A$ be a call target $ct_{A}$ and $B$ a call site $cs_{B}$ than: 
$ct_{A} \subseteq cs_{B} \iff \forall i \subseteq [1, 6],$
\ wideness(parameter($A$)[i]) $\leq$ \ wideness(parameter($B$)[i]).
}
Whereas the policy of TypeArmor is the following. 
\label{eqn:2}{
\textit{Definition 3.2} Let $A$ be a call target $ct_{A}$ and $B$ a call site $cs_{B}$ than: 
$ct_{A} \subseteq cs_{B} \iff \forall i \subseteq [1, 6],$ 
\ count(parameter($A$)) $\leq$ count(parameter($B$)).
}
From Definitions~\eqref{eqn:1} and~\eqref{eqn:2} it can be observed that 
the first policy is more fine-grained than the second one since it performs checks 
for each parameter index in part.

\subsection{Invariants for Calltargets and Callsites}
% \textbf{Invariants for Targets and Callsites.}
\label{Invariants for Targets and Callsites}
Advanced code reuse attacks change the calltargets that are invoked within indirect 
callsites. As standard CFI solutions can hardly restrict these, TypeArmor proposed using two base invariants:
\textit{1)} indirect callsites provide a number of parameters (\textit{i.e.,} possibly overestimated compared to source), and 
\textit{2)} calltargets require a minimum number of parameters (\textit{i.e.,} possibly underestimated compared to source).
The idea is that a callsite might only call functions that do not require more parameters than provided by the callsite. 
To compute the necessary information, TypeArmor uses a modified version of forward liveness analysis for call-targets and 
backward reaching definitions analysis for callsites.

\subsection{Impact of \textsc{TypeShield} on COOP}
% \textbf{\textsc{TypeShield} Impact on COOP.}
\label{TypeShild Impact on COOP}
% \vspace{-.5cm}
\begin{figure}[h!]
\centering
\resizebox{0.28\textwidth}{!}{
\begin{tikzpicture}
\draw[thick] (0,-3) [blue] rectangle node[anchor=center]  (0)  {\HUGE{$\bot$ (0, 0)}}   (2,-4);
\draw[thick] (0,0) rectangle node[anchor=center]  (320)  {\HUGE{(a, 0)}}  (2,-1);
\draw[thick] (3,2) rectangle node[anchor=center]  (640)  {\HUGE{(b, 0)}}  (5,1);
\draw[thick] (0,3) rectangle node[anchor=center]  (3232) {\HUGE{(a, a)}} (2,4);
\draw[thick] (3,5) rectangle node[anchor=center]  (6432) {\HUGE{(b, a)}} (5,6);
\draw[thick] (-1,5) rectangle node[anchor=center] (3264) {\HUGE{(a, b)}} (-3,6);
\draw[thick] (0,7) [blue] rectangle node[anchor=center]  (6464) {\HUGE{$\top$ (b,b)}} (2, 8);

  %%TA and TS
  \draw[draw, -triangle 45, thick] (3264.north) -- (6464.south);
  \draw[draw, -triangle 45, thick] (6432.north) -- (6464.south);
  \draw[draw, -triangle 45, thick] (3232.north) -- (3264.south);
  \draw[draw, -triangle 45, thick] (3232.north) -- (6432.south);
  
  \draw[draw, -triangle 45, thick] (640.north) -- (6432.south);
  \draw[draw, -triangle 45, thick] (320.north) -- (3232.south);
  \draw[draw, -triangle 45, thick] (320.north) -- (640.south);
  \draw[draw, -triangle 45, thick] (0.north) -- (320.south);
  
  %%only TA
  \draw[draw, color=red, dotted, -triangle 45, thick] (640.south) -- (320.east);
  \draw[draw, color=red, dotted, -triangle 45, thick] (640.north) -- (3232.south);
  
  \draw[draw, color=red, dotted, -triangle 45, thick]  (6464.south) -- (3264.east);
  \draw[draw, color=red, dotted, -triangle 45, thick]  (6464.south) -- (6432.west);
  \draw[draw, color=red, dotted, -triangle 45, thick]  (3264.east) -- (3232.north);
  \draw[draw, color=red, dotted, -triangle 45, thick]  (6432.west) -- (3232.north);
  
  %%draw boxes arround
  \draw[thick,dashed] (2.1,0.6) ellipse (4.5cm and 2cm);
   \begin{scope}[xshift=6cm, yshift=-.3cm]
     \node[]    (q_1) {\HUGE{1 parameter}};
   \end{scope}
   
   \draw[thick,dashed] (1,5.5) ellipse (4.8cm and 2.8cm);
   \begin{scope}[xshift=6cm, yshift=6.8cm]
     \node[]    (q_2) {\HUGE{2 parameters}};
   \end{scope}
   
   
   
   \begin{scope}[xshift=5cm, yshift=-1.9cm]
     \node[]    (q_4) {\HUGE{\textit{Legend}}};
   \end{scope}
   
   \begin{scope}[xshift=5.1cm, yshift=-2.7cm]
     \node[]    (q_4) {\HUGE{allowed}};
     \draw[draw, -triangle 45, thick]  (1.2,-.02) -- (2.2,-.02);
   \end{scope}
   
   \begin{scope}[xshift=5.1cm, yshift=-3.4cm]
     \node[]    (q_3) {\HUGE{foridden}};
     \draw[draw, color=red, dotted, -triangle 45, thick]  (1.2,-.05) -- (2.2,-.05);
   \end{scope}
   
   \draw (3.8,-2.3) -- (7.4,-2.3) -- (7.4,-3.7) -- (3.8,-3.7) -- (3.8,-2.3);
   
\end{tikzpicture}

}
\caption{Transition based lattice between call targets and call sites,
$a$ $\wedge$ $b$ $\in \{0-bit, 8-bit, 16-bit, 32-bit, 64-bit\}$ and the two 
function parameters (for brevity) having $\{0-byte, 1-byte, 2-byte, 4-byte, 8-byte\}$ register wideness. 
\textsc{TypeShield} allows a transition from $a \rightarrow b \ iff$ $a_{i} \le b_{i}$ where $i \in [1, 2]$.
Note that $\top$ and $\bot$ represent the top and bottom elements of the lattice, respectively.
An arrow represents an indirect control flow transfer from a callsite to a calltarget. 
The given lattice contains in total 8 black colored (legal) and 6 red colored (illegal) indirect control flow transitions. 
\textsc{TypeShield} allows only the legal transfers, in contrast~\cite{veen:typearmor} allows all.}
\label{fig:lattice3264}
\end{figure}

Figure~\ref{fig:lattice3264} represents a sub-part of the total indirect transfers space in any given C/C++ program represented as a lattice. 
In case a CFI policy schema is based only on parameter count with callsite overestimation and calltarget subestimation 
it is possible that a callsite can use any call-target as long as the number of 
parameters provided and required are fulfilling the policy, even if the parameter types do not match 
(\textit{i.e.,} imagine 8-bit values provided by the callsite but 64-bit values required by the calltarget). 
Such a parameter count based policy is \textit{blind} and would allow any call transfer 
inside the lattice space presented in Figure~\ref{fig:lattice3264} and as such the calltarget set per 
callsite would be too permissive.

In order to effectively deal with this situation we extend the above presented parameter count based policy in order to
be able to deal with function parameter types as well. We introduce the following policy rules: 
\textit{1)} indirect callsites provide a maximum wideness to each parameter, and
\textit{2)} calltargets require a minimum wideness for each parameter. 
Note that for both rules the minimum and maximum wideness for each function 
parameter is possibly underestimated compared to the source code of the program with which we 
also compare in \cref{chapter:Evaluation}.
Also note that the number of provided parameters must be not lower than the requirement number of consumed parameters. 
Finally, our approach is more fine-grained by considering parameter wideness and as such the allowed calltarget lattice 
space is considerably reduced.



% The result is that we split the buckets of TypeArmor up into smaller ones as shown 
% in the limited example depicted in Figure \ref{fig:lattice3264}.
% There we can see that while in a parameter-count oriented schema a callsite classified as (32,32) would be able to 
% call functions classified as (64,0), however in our parameter wideness oriented schema that is not possible.
