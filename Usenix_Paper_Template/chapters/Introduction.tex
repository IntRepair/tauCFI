\section{Introduction}
\label{chapter:Introduction}

\textbf{Motivation.}
\label{Motivation}
Control-Flow Integrity (CFI)~\cite{abadi:cfi2, abadi:cfi} is one of the most used techniques to secure program execution 
flows against advanced Code-Reuse Attacks (CRAs). Advanced CRAs such as the recently published COOP~\cite{schuster:coop} 
and its extensions \cite{crane:readactor++} or the attacks described by the Control Flow Bending paper~\cite{carlini:bending}
are able to bypass most traditional CFI solutions, as they focus on indirect call-sites, which are not as easy to decide at compile time.

\textbf{Problem.} This is a problem for applications written in C++, as one of its principle is inheritance and virtual functions. 
The concept of virtual functions allows the programmer to overwrite a virtual function of the base-class with his
own implementation. While this allows for much more flexible code, this flexibility is the reason COOP actually 
works. The problem is that in order to implement virtual functions, the compiler needs to generate a table of all
virtual functions for each class containing them and provide each instantiation of such a class with a pointer
to said table. COOP now leverages a memory corruption to inject their own object with a fake virtual pointer, 
which basically gives him control over the whole program, while the control flow still looks genuine, as no 
code was replaced. 

\textbf{Current solutions.} There exist several source code based solutions that either insert run-time checks during the compilation of 
the program like SafeDispatch~\cite{safedispatch:jang}, ShrinkWrap \cite{haller:shrinkwrap} or IFCC/VTV~\cite{vtv:tice}, 
which is the solution it is based on. Others modify and reorder the contents of the virtual table as their main 
aspect like the paper by Bounov et al.~\cite{bounov:interleaving}. While the recently published Redactor++~\cite{crane:readactor++}
implements a combination of those ideas.

While this might seem that only C++ is vulnerable, while C is safe, this notion is wrong, as the 
Control Flow Bending paper \cite{carlini:bending} proposes attacks on nginx leveraging global 
function pointers, which are used to provide configurable behavior.

As previously mentioned, there exist many solutions when one tries to tackle this problem while access
to the application in question is provided. However, when we are faced with proprietary third party 
binaries, which are provided as is and without the actual source code, the number of tools that can
protect against COOP or similar attacks is rather low.

\textbf{Lack.} TypeArmor~\cite{veen:typearmor} is such a tool that implements a fine grained forward edge CFI 
solution for binaries. It calculates invariants for call-targets and indirect call-sites based on
the number of parameters they use by leveraging static analysis of the binary, which then is
patched to enforce those invariants during run-time. However, as of today we are not able to 
access the source code of TypeArmor, which is why we implement our own approximation of the 
tool.

The main shortcoming of TypeArmor is that even with high precision in the classification of 
call-targets and call-sites, one cannot exclude calltargets with lower parameter number from 
call-sites, for one due compatibility and also due to variadic functions, which are a special
case in themselves. This basically means that when a call-site prepares 6 parameters, it is 
able to call all address taken functions.

We implemented \textsc{TypeShield} to show a possible remedy of this problem by introducing
parameter types into the classification of call-sites and call-targets. 

\textbf{Our Idea.} In this paper, we present \textsc{TypeShield}, a runtime illegitimate forward 
calls detection tool that can be seamlessly integrated with large scale applications such as web servers.
It takes the binary of an program as input and it can automatically instrument the binary in order
to detect illegitimate indirect calls at runtime.

------
bla...

\textbf{Goal of This Paper.} The aim of this paper is twofold. First, implement our own indirect forward edge 
classification schema in order to fix some of the shortcomings of previous state-of-the-art binary based approaches
used to mitigate indirect forward edge based advanced code reuse attacks such as COOP~\cite{schuster:coop}.
Second, we compared our tool with TypeArmor~\cite{veen:typearmor}.

\textbf{Contributions.} In summary, we make the following contributions:
\label{Contribution}
\begin{itemize}
 \item \textbf{Security analysis of illegitimate forward indirect calls.} 
 We analyzed the usage of illegitimate indirect forward calls in detail,
 thus providing security researchers and
practitioners a better understanding of this emerging
attack vector.

 \item \textbf{Illegitimate indirect calls detection tool.}
 We designed and implemented \textsc{TypeSchield}, a general, automated, and easy to deploy tool
 that can be applied to C/C++ binaries in order to detect and mitigate illegitimate forward indirect calls 
 during runtime. We have shared \textsc{TypeSchield} with other researches and will make our source code 
 publicly available.
 
 \item \textbf{Experiments.} We demonstrate trough extensive experiments that our precise
 binary-level CFI strategy can mitigate advanced code reuse attacks in absence of C++ semantics.
 For example \textsc{TypeSchield} can protect against COOP~\cite{schuster:coop} and its variations currently published 
 variations~\cite{loop:oriented, crane:readactor++, subversive-c:lettner}.
  
\end{itemize}

\label{Outline}
\textbf{Outline.} The rest of this paper is organized as follows.
\cref{C++ Bad Forward Indirect Calls} explains forbidden forward indirect calls issues and their security implications.
\cref{chapter:TypeShild Overview} contains a high level overview of \textsc{TypeShield}.
\cref{chapter:Design} describes the theory used and decisions made during the design of \textsc{TypeShield}.
\cref{chapter:Implementation} briefly presents the implementation details of \textsc{TypeShield}.
\cref{chapter:Evaluation} evaluates several properties of \textsc{TypeShield} and
\cref{chapter:Related_Work} surveys related work, respectively.
\cref{chapter:Future_Work} highlights future research venues while 
\cref{chapter:Discussion} contains the discussion, respectively.
Finally, \cref{chapter:Conclusion} concludes this paper.


