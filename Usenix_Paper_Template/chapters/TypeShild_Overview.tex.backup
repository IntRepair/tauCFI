\section{Overview}
\label{chapter:TypeShild Overview}

% \textbf{Adversary Model and Assumptions.}
\subsection{Adversary Model and Assumptions}
\label{Adversary Model}

We largely use the same threat model and the same basic assumptions as described in the TypeArmor 
paper \cite{veen:typearmor}, meaning that our attacker has read and write access to the data 
sections of the attacked binary.  We also assume that the protected binary does not contain 
self modifying code, handcrafted assembly or any kind of obfuscation. We also consider pages 
to be either writable or executable but not both at the same time. We assume 
that our attacker has the ability to execute a memory corruption to hijack the programs 
control flow and that a solution for backward CFI is in place.

\subsection{Invariants for Targets and Callsites}
% \textbf{Invariants for Targets and Callsites.}
\label{Invariants for Targets and Callsites}
Advanced code reuse attacks change the calltargets that are invoked within indirect 
callsites. As standard CFI solutions can hardly restrict these, TypeArmor proposed using two base invariants:
\textit{1)} indirect callsites provide a number of parameters (\textit{i.e.,} possibly overestimated compared to source), and 
\textit{2)} calltargets require a minimum number of parameters (\textit{i.e.,} possibly underestimated compared to source).
The idea is that a callsite might only call functions that do not require more parameters than provided by the callsite. 
To compute the necessary information, TypeArmor uses a modified version of forward liveness analysis for call-targets and 
backward reaching definitions analysis for callsites.

\subsection{\textsc{TypeShield} Impact on COOP}
% \textbf{\textsc{TypeShield} Impact on COOP.}
\label{TypeShild Impact on COOP}
\begin{figure}[h!]
\centering
\resizebox{0.4\textwidth}{!}{
\begin{tikzpicture}

\draw[thick] (0,-4) [blue] rectangle node[anchor=center]  (0)  {\LARGE{$\bot:$ |0 | 0 | 0 | 0 | 0 | 0 |}}   (6,-5);

\draw[thick] (0,0) rectangle node[anchor=center]  (320)  {\LARGE{|32 | 0 | 0 | 0 | 0 | 0 |}}  (6,-1);

\draw[thick] (7,2) rectangle node[anchor=center]  (640)  {\LARGE{|64 | 0 | 0 | 0 | 0 | 0 |}}  (12,1);

\draw[thick] (0,3) rectangle node[anchor=center]  (3232) {\LARGE{|32 | 32 | 0 | 0 | 0 | 0 |}} (6,4);

\draw[thick] (7,5) rectangle node[anchor=center]  (6432) {\LARGE{|64 | 32 | 0 | 0 | 0 | 0 |}} (12,6);

\draw[thick] (-1,5) rectangle node[anchor=center] (3264) {\LARGE{|32 | 64 | 0 | 0 | 0 | 0 |}} (-6,6);

\draw[thick] (0,7) [blue] rectangle node[anchor=center]  (6464) {\LARGE{$\top:$ 64|64|64|64|64|64|}} (6,8);

  \draw[draw, -triangle 45, thick] (3264.north) -- (6464.south);
  \draw[draw, -triangle 45, thick] (6432.north) -- (6464.south);
  \draw[draw, -triangle 45, thick] (3232.north) -- (3264.south);
  \draw[draw, -triangle 45, thick] (3232.north) -- (6432.south);
  \draw[draw, -triangle 45, thick] (640.north) -- (6432.south);
  \draw[draw, -triangle 45, thick] (320.north) -- (3232.south);
  \draw[draw, -triangle 45, thick] (320.north) -- (640.south);
  \draw[draw, -triangle 45, thick] (0.north) -- (320.south);
  
\end{tikzpicture}
}
\caption{Parameter register wideness based lattice using parameter wideness of 64-bit, 32-bit and 0-bit with six 
function parameters. Note that $\top$ and $\bot$ represents the top and bottom element of the lattice, respectively.
An arrow (\textit{i.e.,} in total 8) represents an indirect control flow transfer from a callsite to a calltarget. Note that~\cite{veen:typearmor}
would allow all 8 illegal control flow transfers and that \textsc{TypeSchield} would forbid all of them.}
\label{fig:lattice3264}
\end{figure}
Figure~\ref{fig:lattice3264} represents the a sub-part of the total indirect transfers space in any given C/C++ program. 
In case a CFI policy schema is based only on parameter count it is possible that any callsite can use any call-target as long as the number of 
parameter requirement is fulfilled, even if the parameter types do not match (\textit{i.e.,} imagine 8-bit values provided by the callsite
but 64-bit values required by the calltarget). Such a parameter type \textit{blind} policy would allow any call transfer inside the lattice
space presented in Figure~\ref{fig:lattice3264} and as such the calltarget set per callsite would be too permissive.

In order to effectively deal with this situation we extend the CFI classification schema to the function parameter types by introducing the following 
policy rules: \textit{1)} indirect callsites provide a maximum wideness to each parameter, and
\textit{2)} calltargets require a minimum wideness for each parameter. Note that for both rules the minimum and maximum wideness for each function 
parameter is possibly underestimated compared to the source code of the program with which we also compare in \cref{chapter:Evaluation}.
Note, that the provision must be no lower than the requirement w.r.t. the number of parameters. 
Finally, our approach is more fine-grained by considering parameter wideness and as such the addressable 
calltarget lattice space is considerably reduced.



% The result is that we split the buckets of TypeArmor up into smaller ones as shown 
% in the limited example depicted in Figure \ref{fig:lattice3264}.
% There we can see that while in a parameter-count oriented schema a callsite classified as (32,32) would be able to 
% call functions classified as (64,0), however in our parameter wideness oriented schema that is not possible.
