#include "llvm/Analysis/IndirectCallSiteVisitor.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/IR/CallSite.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/Support/raw_os_ostream.h"
#include "llvm/Support/raw_ostream.h"

namespace llvm {
#define DEBUG_TYPE "ground_truth"

/*
    if (CS.getCalledFunction() || !CS.getCalledValue())
      return;
    Instruction *I = CS.getInstruction();
    if (CallInst *CI = dyn_cast<CallInst>(I)) {
      if (CI->isInlineAsm())
        return;
    }
    if (isa<Constant>(CS.getCalledValue()))
      return;
    IndirectCallInsts.push_back(I);
*/

namespace {
static bool isIndirCS(ImmutableCallSite &CS) {
  if (!CS.isCall())
    return false;

  if (CS.getCalledFunction() || !CS.getCalledValue())
    return false;

  Instruction const *I = CS.getInstruction();
  if (CallInst const *CI = dyn_cast<CallInst>(I)) {
    if (CI->isInlineAsm())
      return false;
  }
  if (isa<Constant>(CS.getCalledValue()))
    return false;

  return true;
}

struct GroundTruth_MachineFunction : public MachineFunctionPass {
  static char ID; // Pass identification, replacement for typeid
  GroundTruth_MachineFunction() : MachineFunctionPass(ID) {}

  bool runOnMachineFunction(MachineFunction &MF) override {
    auto F = MF.getFunction();
    errs().write_escaped(F->getName()) << "; ";
    errs() << ((F->hasAddressTaken()) ? "<MAT>" : "<MFN>") << "; ";
    // Count (and print) the arguments a callee (function) expects
    auto arguments = 0;
    for (auto itr = F->arg_begin(); itr != F->arg_end(); ++itr, ++arguments)
      errs() << (*itr->getType()) << "; ";

    for (auto i = arguments; i < 6; ++i)
      errs() << "; ";

    errs() << "parameter_count " << arguments << ";";
    errs() << "return_type " << (*F->getReturnType()) << ";" << '\n';

    // Count (and print) the arguments a callsite provides
    for (auto const &mbb : MF) {
      bool is_call = false;
      for (auto const &MI : mbb) {
        if (MI.isCall())
{       
    is_call = true;
 switch (MI.getOpcode()) {
        case X86::CALLpcrel32:
          errs() << "X86::CALLpcrel32:\n";
          break;
        case X86::CALLpcrel16:
          errs() << "X86::CALLpcrel16:\n";
          break;
        case X86::CALL16r:
          errs() << "X86::CALL16r:\n";
          break;
        case X86::CALL16m:
          errs() << "X86::CALL16m:\n";
          break;
        case X86::CALL32r:
          errs() << "X86::CALL32r:\n";
          break;
        case X86::CALL32m:
          errs() << "X86::CALL32m:\n";
          break;
        case X86::FARCALL16i:
          errs() << "X86::FARCALL16i:\n";
          break;
        case X86::FARCALL32i:
          errs() << "X86::FARCALL32i:\n";
          break;
        case X86::FARCALL16m:
          errs() << "X86::FARCALL16m:\n";
          break;
        case X86::FARCALL32m:
          errs() << "X86::FARCALL32m:\n";
          break;
        case X86::CALL64pcrel32:
          errs() << "X86::CALL64pcrel32:\n";
          break;
        case X86::CALL64r:
          errs() << "X86::CALL64r:\n";
          break;
        case X86::CALL64m:
          errs() << "X86::CALL64m:\n";
          break;
        case X86::FARCALL64:
          errs() << "X86::FARCALL64:\n";
          break;
        default:
          errs() << "IGNORE:\n";
          is_call = false;
        }
      }
}
 if (!is_call)
    errs() << "NO_CALL:\n";

      if (auto bb = mbb.getBasicBlock()) {
        for (auto const &instr : *bb) {
          ImmutableCallSite cs(&instr);

          if (isIndirCS(cs)) {
            if (!cs.isMustTailCall()) {
              errs().write_escaped(F->getName()) << "; ";
              errs() << ("<MCS>") << "; ";

              auto site_arguments = 0;

              for (auto const &arg : cs.args()) {
                errs() << (*arg->getType()) << "; ";
                site_arguments++;
              }
              for (auto i = site_arguments; i < 6; ++i)
                errs() << "; ";

              errs() << "parameter_count " << site_arguments << ";";
              errs() << "return_type " << (*cs.getType()) << ";" << '\n';
            }
          }
        }
      } else {
        for (auto const &minstr : mbb) {
          if (minstr.isCall()) {
            errs().write_escaped(F->getName()) << "; ";
            errs() << ("<MCS*>") << "; ";

            if (auto type = minstr.getType())
              errs() << (*type);
            else
              errs() << "<null-type>";
            errs() << "\n";
          }
        }
      }
    }
    return false;
  }
};
}

char GroundTruth_MachineFunction::ID = 0;
static RegisterPass<GroundTruth_MachineFunction>
    XX_function("ground_truth_machine_function",
                "Function analysis pass to generate "
                "the ground truth for callees and call "
                "sites based on machine functions");

FunctionPass *createMachineGroundTruth_FunctionPass() {
  return new GroundTruth_MachineFunction();
}
};

