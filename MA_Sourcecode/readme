How to run TypeShield:

Teil 1.
Dann zu dem tool: eigentlich sollten nur in den bashfiles refrenzen zu
home usw sein, das ganze muss man so modifizieren dass das zum aktuellen
ordnerpfad passt


weiterhin kann man in der testsources sourcestest oder stc_test ka wie
das gerade heisst in der test config datei (wirst du schon finden) mit #
sachen auskommentieren, da sind die einzelnen programme + einstellungen


so, dann gibt es verschiedene bash scripte, die wichtigsten sind das
run_test_compile.sh und das run_test_analysis.sh (sollten so ähnlich
heissen) die machen genau das was man erwartet


dann gibt es run_test_verify_macthing.sh (oder so) das macht ebenfalls
was man erwartet, ansonsten gibt es noch verschiedene run_test*.sh
scripte die alle eigentlich vom namen schon erahnen lassen sollten was
sie machen, generell muss ich dir aber sagen, dass das aktuelle tool
nicht in einem so tollen zustand ist. weiterhin ist das vermutlich noch
buggy und eine wirkliche readme kann ich auch nicht soo einfach zusammen
basteln, da das alles noch sehr experimentell ist (ich selber weiss
gerade garnicht mal was man alles wo einstellen muss, ich kann mal sehen
ob ich die gepatchten python files hochladen kann...)


achja im Makefile zum pass muss man (per auskommentieren) einstellen
welche policy man will (aber mit der neuen version sollte das alles wie
gesagt deutlich einfacher gehen, da dann ein haupt bash file existieren
wird das alles aufrufen kann und die analyse alle möglichen passes
unabhängig voneinander machen kann)


Teil 2.
wir haben keinen patcher der was macht, da ich nicht die zeit dazu habe
und dafür die annotation in dyninst stabiler sein müssen + das was
dyninst emittiert auch nicht so toll ist (via ast) und einfach so
assembler code reinschreiben auch nicht geht, weil dafür keine
schnittstelle existiert

(es gibt einen grund warum ich das gerade umschreibe, von monolithischer
executable zu library + analyzer executable + patcher executable, dann
kann man nämlich auch das data set einfacher auswählen)


kurz gesagt: der patcher ist eine testruine und da wird sich so schnell
nichts bewegen

das prinzip wäre gewesen: in den entrybasic blocks des ursprünglichen
codes NACH der umleitung die dyninst bei relocation emitted einfach
informationen hinterlegen

in jeder callsite vor dem indirekten jump die targetaddresse (welcher
auf den ursprünglichen code zeigen solle)  nehmen mit dem offset
(welches immer gleich ist und halt auf die daten nach der umleitung von
dyninst zeig) verrechnen, das dann dereferenzieren. diese daten dann mit
den erwarteten verrechnen und dann entscheiden ob wir das programm
crashen (die daten der callsite sind in der berechnung hardcoded, der
code wird daher in jede indirect callsite gepatched)

Teil 3.
Ok. Dann macht es eher sind das ich warte bist du ein Haupt bash Skript baust der alles zusammen fasst. 

Btw. Wie sieht ein Kommando Zeilen Befehl der typeshield startet und mit einer binary als Input ausführt?

Welche und wie viele solche Kommando Zeilen Befehle hast du noch benutzt?
ich benutze keine kommando zeilen befehle direkt, ich starte nur die bash scripte, die das dann die python scripte aufrufen, schau doch bitte einfach in die run_*.sh skripte

Was muss man an den Code patches noch gemacht werden das diese laufen? Ich habe geklaubt dass das schon ein gelöste Sache ist.
alles, das ganze ist so mit dyninst nicht machbar

Teil4.
ich hab dir alle notwendigen infos gegeben damit du eine readme bauen kannst, ich weiss nicht was du gestern verstanden hast aber ich habe selber nicht die zeit sowas zu verfassen und ich weiss garnicht mehr was noch alles zu beachten ist, wie gesagt das auf dem repo ist relativ krude und meine aktuelle version ist auch gerade nicht so funktionsfähig und die version davor ist relativ unschön und als zwischending und kann auch nicht alles
weiterhin hab ich nur gesagt dass ich aktuell im umbau bin, ich glaube kaum dass ich bis morgen das ganze so komplett startbar machen kann, es wäre toll aber ich würde nicht damit rechnen und alle skripte die du hast sind alle skripte in der ganzen sache einfach so verwenden wie se benannt sind
was du auch machen kannst ist in die run_test_* skripte schauen und die python scritps die run_test_* haben auch zusätlich reinschreiben, dann wir das skript auch noch ausgeführt

um es nochmal zu wiederholen: so wie das tool gerade ist ist es nicht wirklich benutzerfreundlich und selbst ich hätte probleme da wieder durchzusteigen + readme kann ichwie ich gestern schon gesagt habe nicht schreiben sondern ich habe dir alles an was ich mich so erinnern kann bereits gesagt und mehr als die hinweise die ich dir gegeben habe kann ich dir aktuell auch nicht wirklich helfen bis ich fertig bin

Teil5.
ich denke dass bis dahin der python harness laufen sollte, ich kann dir
morgen abend mehr über den status berichten

+ der konzeptionelle ablauf ist doch nicht so schwer :

pass compilen via makefile im hauptordner (make clean ; make install)

llvm compilen via cmake (build_llvm im hauptordner erzeugen `cmake
../llvm` oder so und dann make mit sovielen threads wie du willst

dann run_test_compile -> run_test_analysis -> run_test_*

pfade sollten nur in den bash dateien sein + alle run_test_*.py scripts
erwarten die selben parameter wie inden run_test*.sh dateien gezeigt
also es ist da schon eine gewisse konsistenz dahinter
